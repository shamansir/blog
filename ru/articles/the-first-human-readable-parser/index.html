


<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />

<meta name="author" content="Ulric Wilfred" />
<meta name="description" content="Блог о программировании и только о нём. Ни слова о луке. Ни одного. Вообще." />
<meta name="generator" content="mynt v0.3.1" />

<link rel="author me ext" href="http://shamansir.github.io" />
<link rel="contents start home" href="/blog/ru/" />
<link rel="index" href="/blog/ru/archives/" />

<link rel="shortcut icon" href="/blog/ru/assets/img/favicon.png" type="image/x-icon" />

<link rel="alternate" href="/blog/ru/feed.xml" type="application/atom+xml" />



<link rel="stylesheet" href="/blog/ru/assets/css/screen.css" media="screen, projection" type="text/css" />
<link rel="stylesheet" href="/blog/ru/assets/css/print.css" media="print" type="text/css" />
  <!--[if IE]>
      <link rel="stylesheet" href="/blog/ru/assets/css/ie.css" media="screen, projection" type="text/css" />
  <![endif]-->
<link rel="stylesheet" href="/blog/ru/assets/css/pygments.trac.css" type="text/css" />


    
        <!-- WebFonts -->
        <link rel="stylesheet" href="//cloud.webtype.com/css/aeaf962b-fb56-4a2d-af48-f7da7a5ede31.css" type="text/css" />
    

    
        <script type="text/javascript">
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-20770637-6', 'auto');
            ga('send', 'pageview');
        </script>
    






    <title>nwao — (возможно) Первый в мире генератор читабельных, хоть и чрезвычайно медленных, парсеров на JS &ndash; Ни слова о луке</title>

</head>

<body>

    <header id="nwao-header">
    <nav id="nwao-nav" role="site-navigation"><ul>
        <li><a href="/blog/ru/" rel="contents" title="Blog">Блог</a></li>
        <li><a href="/blog/ru/archives/" rel="index" title="Архив">Архив</a></li>
        <li><a href="/blog/ru/tags/" title="Метки">Метки</a></li>
        <li><a href="http://shamansir.github.com" rel="author" title="Автор">Автор</a></li>
        <li><a href="/blog/ru/feed.xml" title="Лента RSS">RSS</a></li>
    </ul></nav>

    <h1 id="nwao-title"><a href="/blog/ru/" title="Ни слова о луке">Ни слова о луке</a></h1>
    <div id="nwao-subtitle"><span>сэр шаман рассказывает о чём может</span></div>
</header>

    <ul id="nwao-lang-switch">
        <li><a href="/blog/ru/../" title="English Version">English Version</a></li>
        <li>Russian Version</li>
    </ul>

    <div id="top"></div>

    
        <nav role="breadcrumbs" id="nwao-breadcrumbs">
            
    <ul>
        
            
            

            <li><a href="/blog/ru/">Блог</a></li>
        
            
            

            <li><a href="/blog/ru/articles">Статьи</a></li>
        
            
            

            <li>(возможно) Первый в мире...</li>
        
    </ul>

        </nav>
    

    
        <nav role="dive" id="nwao-dive">
            
    <ul>
        
        
            <li id="nwao-next">
                <a href="/blog/ru/articles/mastering-functional-javascript-slides/"
                   title="Слайды «Постигаем функциональный JavaScript»">Следующая статья</a>
            </li>
        
    </ul>

        </nav>
    

    
        <nav role="table-of-contents" id="nwao-toc">
            <h3>Содержание:</h3><a href="#top" title="наверх">(наверх)</a>
            
    
        
            
            
                <ul>
                    
                        
    
        
            
            <li>
                <a href="#section" title="Обширная предыстория">Обширная предыстория</a>
                
            </li>
        
    

                    
                        
    
        
            
            <li>
                <a href="#section-2" title="Структура парсера">Структура парсера</a>
                
            </li>
        
    

                    
                        
    
        
            
            <li>
                <a href="#section-3" title="Пояснения">Пояснения</a>
                
            </li>
        
    

                    
                        
    
        
            
            <li>
                <a href="#section-4" title="Операторы">Операторы</a>
                
                    <ul>
                        
                            
    
        
            
            <li>
                <a href="#ch" title="1. <code>ch</code>">1. <code>ch</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#match" title="2. <code>match</code>">2. <code>match</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#re" title="3. <code>re</code>">3. <code>re</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#text" title="4. <code>text</code>">4. <code>text</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#maybe" title="5. <code>maybe</code>">5. <code>maybe</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#some" title="6. <code>some</code>">6. <code>some</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#any" title="7. <code>any</code>">7. <code>any</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#and" title="8. <code>and</code>">8. <code>and</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#not" title="9. <code>not</code>">9. <code>not</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#seqnc" title="10. <code>seqnc</code>">10. <code>seqnc</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#choice" title="11. <code>choice</code>">11. <code>choice</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#action" title="12. <code>action</code>">12. <code>action</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#pre" title="13. <code>pre</code>">13. <code>pre</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#xpre" title="14. <code>xpre</code>">14. <code>xpre</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#label" title="15. <code>label</code>">15. <code>label</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#section-5" title="16. Правило">16. Правило</a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#ref" title="17. <code>ref</code>">17. <code>ref</code></a>
                
            </li>
        
    

                        
                            
    
        
            
            <li>
                <a href="#as" title="18. <code>as</code>">18. <code>as</code></a>
                
            </li>
        
    

                        
                    </ul>
                
            </li>
        
    

                    
                        
    
        
            
            <li>
                <a href="#section-6" title="Эпилог">Эпилог</a>
                
            </li>
        
    

                    
                <ul>
            
        
    

        </nav>
    

    <section id="nwao-content" class="nwao-post">
        
    <article>
        <header class="nwao-post-header">
    <h2 class="nwao-post-title">
        <a href="/blog/ru/articles/the-first-human-readable-parser/" title="(возможно) Первый в мире генератор читабельных, хоть и чрезвычайно медленных, парсеров на JS">(возможно) Первый в мире генератор читабельных, хоть и чрезвычайно медленных, парсеров на JS</a>
    </h2>
    <dl class="nwao-post-infoline">
    <dt class="nwao-published">Опубликован</dt>
    <dd class="nwao-published">
        <a href="/blog/ru/archives/2013/"
           title="07 ноября 2013, четверг">
           <time datetime="%d-%m-%Y" pubdate>07 ноя 2013</time>
        </a>
    </dd>
    
        <dt class="nwao-tags-title">Метки</dt>
        <dd>
            <div class="nwao-tags">
                
                    <a href="/blog/ru/tags/functional-programming/" rel="tag"
                       title="Статьи с меткой ''">functional-programming</a>
                    
                        <span class="tag-count">7</span>
                    
                    
                        <span class="nwao-comma">,</span>
                    
                
                    <a href="/blog/ru/tags/javascript/" rel="tag"
                       title="Статьи с меткой ''">javascript</a>
                    
                        <span class="tag-count">15</span>
                    
                    
                        <span class="nwao-comma">,</span>
                    
                
                    <a href="/blog/ru/tags/parsers/" rel="tag"
                       title="Статьи с меткой ''">parsers</a>
                    
                        <span class="tag-count">1</span>
                    
                    
                
            </div>
        </dd>
    
</dl>
</header>

        <div class="nwao-post-content">
            <p>Если ты меня вообще помнишь, читатель — то, наверняка, помнишь и то, что мои посты в подавляющем количестве случаев разочарующе длинны и довольно-таки часто им предшествует лирическая предыстория. Заверяю тебя, этот пост отнюдь не исключение — я настолько же надёжный графоман, как и ранее, а то ещё и более закалённый.</p>

<p>По сходным обстоятельствам, мало что из описанного в тех постах было доведено до идеального состояния и они, скорее, содержали общие предпосылки к размышлениям, нежели описывали законченный продукт — хотя, преимущественно много внимания всегда было уделено использовавшимся решениям. И по этому пункту я не менее верен тебе и сейчас, дорогой читатель.</p>

<p>Как и раньше, в посте будет множество ссылок и отрывков исходного кода.</p>

<p>Всё как в старые добрые времена. Добро пожаловать, друг.</p>
<h1 id="section">Обширная предыстория</h1>
<p>Не знаю, что конкретно ударило мне в голову года эдак два назад, но мне сильно не понравились существующие на тот момент парсеры Markdown, написанные на JS. Ты удивлён, не так ли?</p>

<p>Например, они не умели рендерить блоки кода в субэлементах списков элементов надсписков, а также что-то из расширенного маркдаун-синтаксиса, что лишь мне и было нужно. И ещё, вообще уже не помню зачем, я очень хотел вызывать различный JS-код в качестве реакций на удачные совпадения с правилами.</p>

<p>Поскольку я любитель активно генерализировать задачи, я нашёл отличный генератор JS-парсеров <a href="http://pegjs.majda.cz/">PEG.js</a>, потом нашёл <a href="http://hasseg.org/peg-markdown-highlight/">GUI-ориентированную библиотеку по подсветке markdown-синтаксиса на C++</a> (которая используется в бесплатном, стильном и прекрасном Mac-OS-приложении для редактирования Markdown, не в пример мне кратко именующем себя <a href="http://mouapp.com/">Mou</a>), из которого я выдрал <a href="https://github.com/ali-rantakari/peg-markdown-highlight/blob/master/pmh_grammar.leg">LEG-грамматику Markdown</a> (которая, в свою очередь была модифицирована из <a href="http://web.archive.org/web/20131116073646/https://github.com/jgm/peg-markdown/blob/master/markdown_parser.leg">грамматики Джона МакФерлейна</a>) и начал адаптировать всю эту портянку под PEG.js, параллельно её улучшая.</p>

<p>Чем <a href="https://github.com/shamansir/mdown-parse-pegjs">всё это</a> кончилось? Лишь тем, что я запомнил имя Ali Rantakari, автора библиотеки подсветки синтаксиса, минимум на два года с хвостиком. Не потому что он в чём-либо виноват, а просто вот так вот вышло.</p>

<p>Если взять глубже, всё вышеописанное зашло в свой локальный тупик в тот безрадостный момент, когда я увидел что сгенерированный парсер занимал просто неуважительные для меня 6МБ (по памяти эта цифра может быть воспроизведена неточно, но масштаб трагедии, я думаю, должен быть нагляден; да и вообще, почему-то в голове у меня крутится цифра <strong>24</strong>) неминифицированного JavaScript-кода. Минифицированного — не сильно меньше. Да-да, читатель, ты не ошибся, парсер какого-то (<em>TODO:</em> пометить красным) вшивенького маркдауна, и <strong>6МБ</strong> — это ни в какие ворота.</p>

<p>Тогда мне не особо рассказывали, что генерируемые парсеры таким грешат и код в них отнюдь не обязан быть оптимальным, а преимущественно являётся результатом поэлементной развёртки правил. И что размер не обязательно пропорционален скорости парсинга, даже таким вот трудноподъёмным парсером. Вернее, может и рассказывали, но, признайся мне, что может быть более весёлого в жизни, чем гнуть свою линию.</p>

<p>И, так как мне такого не рассказывали, я очень возмутился — очень много было неоптимальных, с точки JS-программиста, кусков кода в этом парсере, а ещё даже более раздражали Java-подобные имена функций в коде. Вот прям нет сил терпеть. Я даже пример того кода приводить не буду, прошу поверить мне на слово (на самом деле вот отреставрированный вариант, сгенерированный PegJS версии двухгодичной давности, но почему-то в шесть раз меньше по размеру, возможно из-за того что версия недостаточно ранняя ;) ). А вот сравнение современного варианта оригинального PegJS и описываемой здесь модификации.</p>

<p>И я ещё раз перегенерализировал задачу — убедил себя, что не могу позволить себе не привести этот парсер в приличный функциональный вид. Чтобы, например, такое вот правило:</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span>shakespeare = (&quot;To&quot; / &quot;2&quot;) space &quot;b&quot; &quot;e&quot;? space
              (&quot;or&quot; / &quot;|&quot;) space (&quot;not&quot; / &quot;!&quot;) space
              (&quot;to&quot; / &quot;2&quot;) space &quot;b&quot; &quot;e&quot;?
</pre></div>
</td></tr></table></div></div>
<p>Генерировало такой вот парсер:</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nx">rules</span><span class="p">.</span><span class="nx">shakespeare</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="nx">seqnc</span><span class="p">(</span>
      <span class="nx">choice</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s2">&quot;To&quot;</span><span class="p">),</span> <span class="nx">match</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">)),</span>
      <span class="nx">ref</span><span class="p">(</span><span class="nx">rules</span><span class="p">.</span><span class="nx">space</span><span class="p">),</span>
      <span class="nx">match</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="nx">maybe</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">)),</span>
      <span class="nx">ref</span><span class="p">(</span><span class="nx">rules</span><span class="p">.</span><span class="nx">space</span><span class="p">),</span>
      <span class="nx">choice</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s2">&quot;or&quot;</span><span class="p">),</span> <span class="nx">match</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)),</span>
      <span class="nx">ref</span><span class="p">(</span><span class="nx">rules</span><span class="p">.</span><span class="nx">space</span><span class="p">),</span>
      <span class="nx">choice</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s2">&quot;not&quot;</span><span class="p">),</span> <span class="nx">match</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">)),</span>
      <span class="nx">ref</span><span class="p">(</span><span class="nx">rules</span><span class="p">.</span><span class="nx">space</span><span class="p">),</span>
      <span class="nx">choice</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s2">&quot;to&quot;</span><span class="p">),</span> <span class="nx">match</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">)),</span>
      <span class="nx">ref</span><span class="p">(</span><span class="nx">rules</span><span class="p">.</span><span class="nx">space</span><span class="p">),</span>
      <span class="nx">match</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="nx">maybe</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">))</span>
    <span class="p">)</span>
  <span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Или что-то вот такое абстрактное:</p>
<pre><code>foo = &quot;x&quot;+ a:(&quot;-&quot; c:some_rule { return c; })? { return a; }
</code></pre>
<p>Генерировало такой:</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nx">rules</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="nx">action</span><span class="p">(</span>
      <span class="nx">seqnc</span><span class="p">(</span>
        <span class="nx">some</span><span class="p">(</span>
          <span class="nx">match</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="nx">label</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
          <span class="nx">maybe</span><span class="p">(</span>
            <span class="nx">action</span><span class="p">(</span>
              <span class="nx">seqnc</span><span class="p">(</span>
                <span class="nx">match</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">),</span>
                <span class="nx">label</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span>
                  <span class="nx">ref</span><span class="p">(</span><span class="nx">rules</span><span class="p">.</span><span class="nx">some_rule</span><span class="p">)</span>
                <span class="p">)</span>
              <span class="p">),</span>
              <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span><span class="p">;</span> <span class="p">}</span>
            <span class="p">)</span>
          <span class="p">)</span>
        <span class="p">)</span>
      <span class="p">),</span>
      <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">)</span>
  <span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>На мой двуглазый взгляд любой лиспер поймёт, как работает приведённый код, если даже оставит открытым один лишь третий глаз. И закроет оба моих.</p>

<p>Такова была цель, и, надеюсь, ты согласишься, как идея она была достаточно красива.</p>

<p>… И вполне исполнима. Спустя аж джва с лишним года, её реализация у меня таки <strong><em>вышла</em></strong>! Не скажу, что я прямо так уж сильно торопился, я периодически вообще забрасывал это дело и преключался на другие, немногим более перспективные, а то и вообще уходил в запой. Тем не менее, два года, вечерами, я по крупинке ковырял код и тесты просто ради того, чтобы чем-то себя занять. Продумывал оптимизации и «операторы» в неподходящих жизненных ситуациях, в непредназначающихся обстановках, в неположенное время — точно так, как делает любой уважающий себя нерд.</p>

<p>Это хорошие новости. Но, как всегда, нашлись и плохие. И, конечно же грустные. Приведу <a href="https://gist.github.com/shamansir/7346436">статистику</a> (как только gist выдержал эти килограммы?):</p>

<ul>
<li><p><a href="https://github.com/dmajda/pegjs/blob/master/examples/css.pegjs">css.pegjs</a> — исходная грамматика</p>

<ul>
<li><em>размер:</em> 13.4кБ</li>
<li><em>строк:</em> 552 ± 15 на комментарии</li>
</ul></li>
<li><p><a href="https://gist.github.com/shamansir/7274681#file-css-old_pegjs-parser-js">css.old_pegjs.parser.js</a> — парсер, сгенерированный оригинальной версией PEG.js двухгодичной давности, коммит 4f86fca3d7</p>

<ul>
<li><em>размер:</em> <strong>367кБ</strong></li>
<li><em>строк:</em> 11,378 ± 15 на комментарии,</li>
<li><em>парсинг <a href="https://github.com/dmajda/pegjs/blob/master/benchmark/css/blueprint/min/screen.css">файла</a> размером 11.8кБ x 10 раз:</em> <strong>11.60мс</strong></li>
</ul></li>
<li><p><a href="https://gist.github.com/shamansir/7274681#file-css-cur_pegjs-parser-js">css.cur_pegjs.parser.js</a> — парсер, сгенерированный текущей оригинальной версией PEG.js,</p>

<ul>
<li><em>размер:</em> <strong>334кБ</strong>,</li>
<li><em>строк:</em> 11,225 ± 15 на комментарии,</li>
<li><em>парсинг <a href="https://github.com/dmajda/pegjs/blob/master/benchmark/css/blueprint/min/screen.css">файла</a> размером 11.8кБ x 10 раз:</em> <strong>19.40мс</strong></li>
</ul></li>
<li><p><a href="https://gist.github.com/shamansir/7274681#file-css-cur_pegjs_fn-parser-js">css.pegjs_fn.parser.js</a> — парсер, сгенерированный моей текущей версией PEG.js-FN,</p>

<ul>
<li><em>размер:</em> <strong>107кБ</strong>,</li>
<li><em>строк:</em> 4,452 ± 200 на комментарии (у меня много комментариев и там много чего свернуть можно),</li>
<li><em>парсинг <a href="https://github.com/dmajda/pegjs/blob/master/benchmark/css/blueprint/min/screen.css">файла</a> размером 11.8кБ x 10 раз:</em> <strong>561.60мс</strong></li>
</ul></li>
</ul>

<p>То есть при не-особо-сильной экономии на размере, скорость увеличилась не просто кардинально, а катастрофически (в 30 раз относительно текущей версии). Можно свалить на частный случай парсера, JSON-парсер парсит всего в 5-20 раз дольше оригинала, но к сожалению скорость парсинга увеличивается экспоненциально относительно размера парсящегося файла (как ты думаешь, читатель, может это подсказка?).</p>

<p>Но я пока ещё ничего не оптимизировал. Вообще. Даже не брался.</p>

<p>Отдельная беда в том, что автор PEG.js, <a href="http://majda.cz/">David Majda</a>, пока я ковырялся со своей версией, перевёл всё своё хозяйство на псевдо-байткод (статистика выше, тем не менее, представлена именно с байткодовой версией). Нет, безусловно я следил за тем, что там происходит, и исправно обновлял тесты на новые. Но я хотел добиться своего результата, так как вообще не с чем было даже сравнить, чтобы оценить уровень бесполезности моей идея. Кстати, 469 тестов, это вам не хухры-мухры. Очень приятно смотреть, как они все проходят. Особенно после моментов, когда до этого бывало такое, что в десятый раз исправляешь три теста и начинают валиться пятьдесят. Впрочем, тебя таким не удивить.</p>

<p>Однако, как видишь, дорогой читатель, все означенные расстройства не остановили меня от написания статьи. Если бы можно было принять критерием читабельность кода парсера, я бы поделил скорость парсинга на его значение, тем самым уменьшив его в 200 раз, и стал бы окончательно счастлив. Кстати, <a href="https://twitter.com/dudnik">Никита</a>, благодарю за подбадривание с самого начала этой истории.</p>

<p>Оптимизацию я наметил на будущее, может быть что-то и выйдет. Но сейчас никак нельзя останавливаться.</p>

<p>Ибо в процессе, как я считаю, я изобрёл <strong><em>Функциональные Операторы Парсинга</em></strong> (если только их ещё не придумали в Хаскеле — иначе я сильно опоздал и остаётся лелеять надежду на туманный шанс запатентовать прелестный термин).</p>

<p>О них и пойдёт речь.</p>

<p>Ах да, все исходники — в моём проекте <a href="https://github.com/shamansir/pegjs-fn">PEG.js-FN</a> на гитхабе.</p>
<h1 id="section-2">Структура парсера</h1>
<p>В парсерах, сгенерированных PEGjs-FN (в отличие, кстати, от оригинала [по крайней мере, на данный момент]), пользовательский код чётко отделяется от кода самого парсера собственной областью видимости.</p>

<p>«Что за пользовательский код?», — спросишь ты.</p>

<p>В PEG.js есть замечательная возможность заключить любую часть правила грамматики в скобки и выполнить некий JS-код, если эта часть совпала с исходной строкой. При этом в JS-коде, в виде переменных, доступны все предшествующие именованные совпадения, находящиеся на том же уровне контекста или выше. Эти «совпадения» также могут скрывать под собой другой JS-код, по такому же принципу возвращающий и выполняющий всё, что программисту угодно.</p>

<p>Возьмём пример выше:</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>foo = &quot;x&quot;+ a:(&quot;-&quot; c:some_rule { return c; })? { return a; }
</pre></div>
</td></tr></table></div></div>
<p>Если ты знаком с PEG-грамматикой, то ты всё понял. Если нет — то нет, но не отчаивайся, я попробую объяснить.</p>

<p>Здесь совпадение с именем a должно бы было возвращать символ &ldquo;-&rdquo;, конкатенированный с результатом парсинга по правилу <code>some_rule</code> — но действие этого совпадения <em>переопределено</em> и оно возвращает только результат парсинга по правилу <code>some_rule</code>. Тем же образом, совпадение по правилу <code>foo</code> в данном случае возвращает не набор символов «x», конкатенированных с результатом парсинга по последовательности <code>a</code> — а лишь результат парсинга по последовательности <code>a</code>. А могло и запустить искуственный интеллект, который вернул бы новейший сонет Шекспира.</p>

<p>Кроме того, PEG.js предоставляет и другую замечательную возможность: предварить весь парсер неким глобальным (для парсера) JS-кодом, который, следовательно, будет доступен всем таким блокам кода. В PEG.js такой код именуется <em>инициализатором</em>.</p>

<p>Совокупность описанных возможностей и есть <em>пользовательский код</em> — по сути, любой JS-код, содержащийся в грамматике.</p>

<p>Итак, структура:</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

 <span class="c1">// общие для пользовательского кода и парсера переменные</span>
 <span class="kd">var</span> <span class="nx">input</span><span class="p">,</span> <span class="nx">ppos</span><span class="p">,</span> <span class="nx">pos</span><span class="p">;</span>

 <span class="c1">// весь пользовательский код, изолированный от кода парсера</span>
 <span class="kd">var</span> <span class="nx">__user_code</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

   <span class="c1">// функции, предоставляемые пользователю парсером</span>
   <span class="kd">function</span> <span class="nx">offset</span><span class="p">(),</span> <span class="kd">function</span> <span class="nx">text</span><span class="p">(),</span> <span class="p">...</span>

   <span class="c1">// инлайн-код пользовательского инициализатора</span>
   <span class="kd">function</span> <span class="nx">PARSE_ME_BABY</span><span class="p">...</span>
   <span class="kd">function</span> <span class="nx">SHIT_THAT_KILLED_ELVIS</span><span class="p">...</span>

   <span class="k">return</span> <span class="p">{</span>
     <span class="c1">// сгруппированные по имени правила блоки пользовательского кода</span>
     <span class="nx">foo</span><span class="o">:</span> <span class="p">[</span> <span class="kd">function</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span><span class="p">;</span> <span class="p">})(</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">c</span><span class="p">);</span> <span class="p">},</span>
            <span class="kd">function</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="p">;</span> <span class="p">})(</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span> <span class="p">}</span>  <span class="p">]</span>
     <span class="p">...</span>
   <span class="p">}</span>

 <span class="p">};</span>

 <span class="c1">// код парсера, изолированный от пользовательского кода</span>
 <span class="k">return</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

   <span class="c1">// переменные, доступные только правилам, операторам и парсеру</span>
   <span class="kd">var</span> <span class="nx">code</span><span class="p">,</span> <span class="nx">rules</span> <span class="o">=</span> <span class="p">{};</span>

   <span class="c1">// код правил, входящих в данный парсер</span>
   <span class="nx">rules</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="kd">var</span> <span class="nx">code</span> <span class="o">=</span> <span class="nx">code</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
                            <span class="k">return</span> <span class="nx">action</span><span class="p">(</span><span class="nx">seqnc</span><span class="p">(...))(</span><span class="nx">code</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="p">}</span>
   <span class="nx">rules</span><span class="p">.</span><span class="nx">start</span> <span class="o">=</span> <span class="nx">rules</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>

   <span class="c1">// все использующиеся в парсере операторы</span>
   <span class="c1">// (неиспользующиеся не включаются)</span>
   <span class="kd">function</span> <span class="nx">action</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
   <span class="kd">function</span> <span class="nx">seqnc</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
   <span class="kd">function</span> <span class="nx">match</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
   <span class="p">...</span>

   <span class="c1">// парсеро-независимые утилиты и хелперы</span>
   <span class="p">...</span>

   <span class="k">return</span> <span class="p">{</span>
     <span class="p">...</span>
     <span class="nx">parse</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">_input</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">input</span> <span class="o">=</span> <span class="nx">_input</span><span class="p">;</span>
        <span class="nx">code</span> <span class="o">=</span> <span class="nx">__user_code</span><span class="p">();</span>
        <span class="k">return</span> <span class="nx">rules</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span>
     <span class="p">}</span>
   <span class="p">}</span>

 <span class="p">})();</span>

<span class="p">})();</span>
</pre></div>
</td></tr></table></div></div>
<p>Довольно просто, не правда ли? :)</p>
<h1 id="section-3">Пояснения</h1>
<p>Области видимости операторов в парсере реализованы через цепочки прототипов JS, то есть на каждую вложенную область видимости создаётся JS-объект, свойства которого хранят текущую область видимости, а прототип указывает на родительскую область видимости. Возможно, этот факт тоже пагубно влияет на скорость.</p>

<p>Все результаты выполнения правил кэшируются по ключу «имя правила + позиция во входной строке», как и в оригинале.</p>

<p>При неудачном парсинге выбрасывается исключение <code>MatchFailed</code>, которое, если не было перехвачено, снабжается дополнительной информацией, вроде двумерных координат неудачи (строка: столбец), и выдаётся пользователю.</p>
<h1 id="section-4">Операторы</h1>
<p>Краткий вводный ликбез дан, можем перейти непосредственно к разбору операторов.</p>

<p>Секрет <em>операторов парсинга</em> — а по-другому их и не назовёшь – в том, что все они — суть <a href="http://shamansir.github.io/blog/ru/articles/the-way-of-the-asynchronous-samurai/#%E3%83%A2%E3%83%8A%E3%83%80%E3%81%AE%E7%A9%BA%E9%81%93">отложенные функции</a>. Когда они вызываются в первый раз, в них передаётся лишь часть контекста вызова и она надёжно хранится вплоть до момента второго вызова, когда бы он ни произошёл. Эту технику также называют <a href="http://en.wikipedia.org/wiki/Partial_application">частичным применением</a>, и будь ты хаскелист или скалист, она тебе знакома на все сто.</p>

<p>В JavaScript для реализации частичного применения можно построить либо небольшую лесенку из анонимных функций, либо использовать <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">Function.bind</a>. Я, как и писал в статье <a href="http://shamansir.github.io/blog/ru/articles/the-way-of-the-asynchronous-samurai/">про Асинхронного Самурая</a>, остановился на первом варианте. Не стоит ныне напускать ненужной важности на этот приём, по-моему тот пост и так понапустил достаточно.</p>

<p>Что это даёт нам?</p>

<p>Частичное применение решает все проблемы создания функциональных и читабельных парсеров одним махом. По крайней мере, если у вас на руках AST-дерево грамматики (а PEG.js мастерски создаёт AST-деревья).</p>

<p>Предположим, у вас есть активный на текущий момент оператор, который выполняет последовательность других операторов, одного за другим, но если какой-то из них не совпал со строкой ввода, не бьёт панику, прерывая работу парсера и ругаясь несовпадениями, а тихо откатывается назад.</p>

<p>То есть если один из цепочки операторов бросает исключение, надо первое же из них перехватить и подавить. А ведь этот оператор может состоять из уходящих далеко вглубь цепочек других операторов. Или сам быть где-то в глубине этой цепочки. Далекой-далекой глубине. Но при этом всегда конечной.</p>

<p>Применив частичное применение (<em>TODO:</em> убрать тавтологию) к каждому из дочерних операторов мы, при первом вызове, «замораживаем» слепки информации об их вызове по цепочке, принуждая их сохранить данные о своих внутренних операторах. Затем для каждого из внутренних операторов второго уровня мы рекурсивно повторяем это действие — и так далее и далее вглубь. Это первая часть контекста. При этом наш активный оператор таким же образом «замораживает» всю цепочку целиком при первом вызове себя любимого.</p>

<p>Например, код <code>sequence(match(&quot;foo&quot;), or(match(&#39;bar&#39;), ch()))</code>, запомнит лишь (внутри оператора <code>sequence</code>), что в этой точке надо будет попробовать сравнить входную строку со строкой <code>&quot;foo&quot;</code>, затем попробовать сравнить оставшуюся часть c <code>&quot;bar&quot;</code>, а если не выйдет — откатиться и убедиться что строка не кончилась и следующим за <code>&quot;foo&quot;</code> идёт некий символ (так действует оператор <code>ch()</code>). Но он не выполнит этих действий фактически, а «притормозит» их до следующего вызова <code>sequence</code>.</p>

<p>И один единственный толчок — второй вызов активного оператора, запускает мощный импульс развёртки — словно доминошки, расставленные в форме дерева, они начинают задевать друг друга, приоткрывая своим падением совпавшие строки и результаты JS-кода, пока в конце концов импульс не дойдёт до кончика самой длинной ветки. (<em>FIXME:</em> слишком качественная аллегория).</p>

<p>Или не дойдёт, если какая-то из неудач парсинга не была подавлена логикой парсера и просочилась наружу.</p>

<p>Собрав результаты вместе, мы получаем результат парсинга этого оператора. И группы операторов, в которую он входит. Таким же образом мы выполняем и правила, придавая импульс цепочке операторов внутри них. Потому что правила — те же операторы парсинга, и единственное их отличие — в том, что они не предопределены — вернее, описаны самим пользователем. Но принцип их «откладывания» идентичен принципу «откладывания» операторов. И начинаем парсить весь текст мы с того же единственного импульса — запускаем искру стартового правила — и вжих!</p>

<p>Если вам всё ещё не очень понятно, попробуйте сравнить грамматику и код сгенерированного парсера <a href="https://gist.github.com/shamansir/7249136">в этом примере</a> (там есть выдержка из парсера и сгенерированный парсер целиком).</p>

<p>Оптимизации, кстати, если и затронут код операторов вообще, то затронут минимально — в плане смены форматов вызова внутренних функций парсера, что никоим образом не поменяет их логики.</p>

<p>Наконец, пройдёмся по каждому из операторов подробнее. Код большинства из них не превышает десяти строк, но я постараюсь максимально уныло описать действие каждого — подобно тому, как это делают в справочниках. На самом деле самое важное в нижеследующей части — именно код операторов, ибо он подобен паттернам — а я продолжу надеяться, что он понятен без пояснений: даже несмотря на то, что в целях экономии места и незамутнённости твоего взора я опустил код некоторых внутренних функций парсера вроде <code>safe</code>, <code>failed</code> и <code>inctx</code> (их код, при необходимости, можно подсмотреть по ссылке из предыдущего абзаца (<a href="https://gist.github.com/shamansir/7249136#file-arithmetics-parser-full-js">повторю её</a>, чтобы ты лишний раз не бегал глазами)).</p>
<h2 id="ch">1. <code>ch</code></h2>
<p><strong>Описание:</strong> Проверить, имеется ли в текущей позиции какой бы то ни было символ и вернуть его. Конец строки ввода в текущей позиции расценивается как ошибка парсинга.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>.</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">ch</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">pos</span> <span class="o">&gt;=</span> <span class="nx">ilen</span><span class="p">)</span> <span class="nx">failed</span><span class="p">(</span><span class="nx">ANY</span><span class="p">,</span> <span class="nx">EOI</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">input</span><span class="p">[</span><span class="nx">pos</span><span class="o">++</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Если текущая позиция парсинга по значению больше или равна длине строки, сообщить о том, что парсинг не удался, и при том, что ожидался любой символ (маркер <code>ANY</code>), был обнаружен конец ввода (маркер <code>EOI</code> — <em>End of Input</em>): функция <code>failed</code> конструирует исключение <code>MatchFailed</code> и выбрасывает его наружу.</p>

<p>Если позиция находится в пределах длины строки — возвращает текущий символ, затем инкрементируя позицию парсинга.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = . . .</span>
<span class="nx">seqnc</span><span class="p">(</span><span class="nx">ch</span><span class="p">(),</span> <span class="nx">ch</span><span class="p">(),</span> <span class="nx">ch</span><span class="p">())();</span> <span class="c1">// == [ &#39;f&#39;, &#39;o&#39;, &#39;o&#39; ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="match">2. <code>match</code></h2>
<p><strong>Описание:</strong> Сравнить входную строку с переданной, стартовав с текущей позиции;</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&quot;строка&quot;</code>, <code>&#39;строка&#39;</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">match</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">slen</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="nx">pos</span> <span class="o">+</span> <span class="nx">slen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nx">ilen</span><span class="p">)</span> <span class="p">{</span> <span class="nx">failed</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="nx">EOI</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="nx">pos</span><span class="p">,</span> <span class="nx">slen</span><span class="p">)</span> <span class="o">===</span> <span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">pos</span> <span class="o">+=</span> <span class="nx">slen</span><span class="p">;</span> <span class="k">return</span> <span class="nx">str</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">failed</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="nx">cc</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Если сумма значений текущей позиции и длины переданной строки больше длины входной строки, сообщить о неудаче парсинга, пояснив, что ожидалась переданная строка, а был обнаружен конец ввода (маркер <code>EOI</code> — <em>End of Input</em>).</p>

<p>Если участок ввода, начинающийся от текущей позиции парсинга и равный по длине переданной строке идентичен по содержимому переданной строке, увеличить позицию парсинга на длину переданной строки и вернуть её.</p>

<p>Если участок не идентичен переданной строке, сообщить о несовпадении, пояснив, что ожидалась переданная строка, а был обнаружен другой символ: функция <code>cc()</code> (не путать с оператором <code>ch</code>) возвращает текущий символ или маркер <code>EOI</code>, если текущая позиция превышает длину строки ввода.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = . &#39;oo&#39;</span>
<span class="nx">seqnc</span><span class="p">(</span><span class="nx">ch</span><span class="p">(),</span> <span class="nx">match</span><span class="p">(</span><span class="s2">&quot;oo&quot;</span><span class="p">))();</span> <span class="c1">// == [ &#39;f&#39;, &#39;oo&#39; ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="re">3. <code>re</code></h2>
<p><strong>Описание:</strong> Сравнить входную строку с переданным регулярным выражением, начиная с текущей позиции парсинга. На самом деле в PEG.js намеренно запрещены все регулярные выражения кроме наборов символов в виде <code>[...]</code> и <code>[^...]</code> (чтобы пользователь не имел возможности заменить правила PEG «конкурирующими» спецификациями). По этой причине и внутрь данного оператора враг не пройдёт, а будет вырезан на этапе составления AST-дерева. С другой стороны, в этот же оператор перенаправляются проверки <code>match</code> с ignore-case флагом.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>[&lt;символы&gt;]</code>, <code>[^&lt;символы&gt;]</code>, <code>[&lt;символ1&gt;-&lt;символn&gt;]</code>, <code>[^&lt;символ1&gt;-&lt;символn&gt;]</code>, <code>&quot;строка&quot;i</code>, <code>&#39;&lt;строка&gt;&#39;i</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">re</span><span class="p">(</span><span class="nx">rx</span><span class="p">,</span> <span class="nx">desc</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">desc</span> <span class="o">=</span> <span class="nx">desc</span> <span class="o">||</span> <span class="nx">rx</span><span class="p">.</span><span class="nx">source</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">res</span> <span class="o">=</span> <span class="nx">rx</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="nx">pos</span><span class="p">)))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">index</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">failed</span><span class="p">(</span><span class="nx">desc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">());</span>
    <span class="nx">pos</span> <span class="o">+=</span> <span class="nx">res</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span> <span class="k">return</span> <span class="nx">res</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nx">failed</span><span class="p">(</span><span class="nx">desc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Принимает объект регулярного выражения <code>rx</code> и его символьное описание <code>desc</code>. Выполняет сравнение входной строки с <code>rx</code>, начиная с текущей позции парсинга.</p>

<p>Если сравнение не удалось, с помощью функции <code>failed()</code> выбрасывает исключение <code>MatchFailed</code> с пояснением, что ожидалось описанное в <code>desc</code>, а был найден символ на текущей позиции, который возвращает функция <code>cc()</code> (не путать с <code>ch</code>).</p>

<p>Если сравнение удалось — увеличивает позицию парсинга на длину совпавшей строки и возвращает последнюю.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = [^f-o]+</span>
<span class="nx">some</span><span class="p">(</span><span class="nx">re</span><span class="p">(</span><span class="sr">/[^p-v]/</span><span class="p">))();</span> <span class="c1">// == [ &#39;f&#39;, &#39;o&#39;, &#39;o&#39; ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="text">4. <code>text</code></h2>
<p><strong>Описание:</strong> Вместо комплексного результата выражения вернуть совпадающий текст. Имеет смысл, например, при переопределении оператора <code>seqnc</code>, который «упаковывает» результаты последовательности операторов в массив.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>$&lt;выражение&gt;</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">text</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">p_pos</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">;</span>
  <span class="nx">f</span><span class="p">();</span> <span class="k">return</span> <span class="nx">input</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="nx">p_pos</span><span class="p">,</span> <span class="nx">pos</span><span class="o">-</span><span class="nx">p_pos</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Сохранить <em>локально</em> предыдущую позицию парсинга, выполнить переданный оператор <em>f</em> не сохраняя возвращённого им результата и вернуть отрезок входной строки между предыдущей позицией парсинга и новой (выполнение операторов влияет на позицию). Если было выброшено и не перехвачено исключение, парсинг прекращается.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = $(. . .)</span>
<span class="nx">text</span><span class="p">(</span><span class="nx">seqnc</span><span class="p">(</span><span class="nx">ch</span><span class="p">(),</span> <span class="nx">ch</span><span class="p">(),</span> <span class="nx">ch</span><span class="p">()))();</span> <span class="c1">// == [ &#39;foo&#39; ], а не [ &#39;f&#39;, &#39;o&#39;, &#39;o&#39; ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="maybe">5. <code>maybe</code></h2>
<p><strong>Описание:</strong> Проверить, присутствует ли данное выражение во входной строке максимум один раз, и если да — переместить позицию на конец совпадения, а если нет — не совершать ничего.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&lt;выражение&gt;?</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">maybe</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">missed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">res</span> <span class="o">=</span> <span class="nx">safe</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">missed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">});</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">missed</span><span class="p">)</span> <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Выполнить переданный оператор <code>f</code> в безопасном контексте с помощью функции <code>safe</code>, которая передаёт исключение, если оно возникло при выполнении оператора, в переданную вторым параметром анонимную функцию, которая, в свою очередь, устанавливает флаг <code>missed</code> в единицу. Если флаг <code>missed</code> установлен, вернуть пустую строку, иначе вернуть результат выполнения оператора.</p>

<p>Когда совпадение имело место, позиция парсинга корректно перемещается оператором <code>f</code> или операторами, которые он вызывает.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = &#39;f&#39;? (. .)?</span>
<span class="nx">seqnc</span><span class="p">(</span><span class="nx">maybe</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)),</span> <span class="nx">maybe</span><span class="p">(</span><span class="nx">seqnc</span><span class="p">(</span><span class="nx">ch</span><span class="p">(),</span> <span class="nx">ch</span><span class="p">())))();</span> <span class="c1">// == [ &#39;f&#39;, [ &#39;o&#39;, &#39;o&#39; ] ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="some">6. <code>some</code></h2>
<p><strong>Описание:</strong> Проверить, присутствует ли данное выражение во входной строке минимум один раз и переместить позицию на конец совпадения или нескольких совпадений.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&lt;выражение&gt;+</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">some</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">f</span><span class="p">()].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">any</span><span class="p">(</span><span class="nx">f</span><span class="p">)());</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Выполнить переданный оператор <code>f</code> в небезопасном контексте, то есть если будет выброшено исключение, то действие оператора <code>some</code> будет остановлено, и затем объединить его результат с результатом выполнения оператора <code>any</code> (проверить на ноль или более совпадений и вернуть их), рассмотренного ниже, с теми же параметрами.</p>

<p>Когда совпадения имели место, позиция парсинга корректно перемещается оператором <code>f</code> или операторами, которые он вызывает.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = &#39;f&#39;? .+</span>
<span class="nx">seqnc</span><span class="p">(</span><span class="nx">maybe</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)),</span> <span class="nx">some</span><span class="p">(</span><span class="nx">ch</span><span class="p">()))();</span> <span class="c1">// == [ &#39;f&#39;, [ &#39;o&#39;, &#39;o&#39; ] ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="any">7. <code>any</code></h2>
<p><strong>Описание:</strong> Проверить максимальное количество последовательных совпадений с данным выражением. Если совпадения были — переместить позицию парсинга на конец последнего совпадения, если совпадений не было — просто ничего не совершать.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&lt;выражение&gt;*</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">any</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="p">[],</span>
      <span class="nx">missed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">on_miss</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">missed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">missed</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">safe</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">on_miss</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">missed</span><span class="p">)</span> <span class="nx">s</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Выполнять переданный оператор <code>f</code> в безопасном контексте с помощью функции <code>safe</code> пока флаг <code>missed</code> не будет установлен в единицу (совпадения кончились). Функция <code>safe</code> передаёт исключение, если оно возникло при выполнении оператора в функцию <code>on_miss</code>, которая, в свою очередь, устанавливает флаг <code>missed</code>. Все удачные результаты накапливаются в массив <code>s</code>.</p>

<p>Если флаг <code>missed</code> был установлен, убрать последний (сорвавшийся) результат из массива <code>s</code> и вернуть его; иначе вернуть массив с результами <code>s</code> без изменений.</p>

<p>Когда совпадение имело место, позиция парсинга корректно перемещается оператором <code>f</code> или операторами, которые он вызывает.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = &#39;f&#39;+ &#39;o&#39;*</span>
<span class="nx">seqnc</span><span class="p">(</span><span class="nx">some</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)),</span> <span class="nx">any</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)))();</span> <span class="c1">// == [ [ &#39;f&#39; ], [ &#39;o&#39;, &#39;o&#39; ] ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="and">8. <code>and</code></h2>
<p><strong>Описание:</strong> Проверить совпадение и если оно имело место, вернуть пустую строку и <em>не</em> передвигать позицию парсинга. Если совпадения не произошло, выбросить ошибку парсинга.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&amp;&lt;выражение&gt;</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">and</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">p_pos</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">,</span> <span class="nx">missed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">safe</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">missed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">});</span> <span class="nx">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">pos</span> <span class="o">=</span> <span class="nx">p_pos</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">missed</span><span class="p">)</span> <span class="nx">failed</span><span class="p">(</span><span class="nx">EOI</span><span class="p">,</span> <span class="nx">cc</span><span class="p">());</span>
  <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Сохранить позицию <em>локально</em> и выполнить переданный оператор <code>f</code> в безопасном контексте с помощью функции <code>safe</code>. Функция <code>safe</code> передаёт исключение, если оно возникло при выполнении оператора, в анонимную функцию, которая, в свою очередь, устанавливает флаг <code>missed</code>.</p>

<p>Перед выполнением оператора <code>f</code> все возникшие исключения подавляются флагом <code>nr</code> (<em>not report</em>), парсер проверяет этот флаг при несовпадениях и если он установлен, <em>не</em> накапливает информацию о произошедшем (иначе даже подавленные исключения сохраняют информацию о несовпадениях и переносят её в финальную ошибку парсинга). После выполнения оператора значение флага возвращается в ложь.</p>

<p>Затем значение позиции парсинга откатывается до предыдущего (это важно сделать до сообщения об ошибке или возвращения значения) и если имело место исключение, порождается ошибка парсинга с пояснением, что ожидался конец ввода (маркер <code>EOI</code>, <em>End of Input</em>), а был обнаружен текущий символ; если исключений не было, оператор возвращает пустую строку.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = &amp;&#39;f&#39; &#39;foo&#39;</span>
<span class="nx">seqnc</span><span class="p">(</span><span class="nx">and</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)),</span> <span class="nx">match</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">))();</span> <span class="c1">// == [ &#39;&#39;, &#39;foo&#39; ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="not">9. <code>not</code></h2>
<p><strong>Описание:</strong> Проверить совпадение и если оно <em>не</em> имело места, вернуть пустую строку и не передвигать позицию парсинга. Если совпадене произошло, выбросить ошибку парсинга.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>!&lt;выражение&gt;</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">not</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">p_pos</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">,</span> <span class="nx">missed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">safe</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">missed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">});</span> <span class="nx">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">pos</span> <span class="o">=</span> <span class="nx">p_pos</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">missed</span><span class="p">)</span> <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
  <span class="nx">failed</span><span class="p">(</span><span class="nx">EOI</span><span class="p">,</span> <span class="nx">cc</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Сохранить позицию <em>локально</em> и выполнить переданный оператор <code>f</code> в безопасном контексте с помощью функции <code>safe</code>. Функция <code>safe</code> передаёт исключение, если оно возникло при выполнении оператора, в анонимную функцию, которая, в свою очередь, устанавливает флаг <code>missed</code>.</p>

<p>Перед выполнением оператора <code>f</code> все возникшие исключения подавляются флагом <code>nr</code> (<em>not report</em>), парсер проверяет этот флаг при несовпадениях и если он установлен, <em>не</em> накапливает информацию о произошедшем (иначе даже подавленные исключения сохраняют информацию о несовпадениях и переносят её в финальную ошибку парсинга). После выполнения оператора значение флага возвращается в ложь.</p>

<p>Затем значение позиции парсинга откатывается до предыдущего (это важно сделать до сообщения об ошибке или возвращения значения) и если имело место исключение, оператор возвращает пустую строку; если исключений не было, порождается ошибка парсинга с пояснением, что ожидался конец ввода (маркер <code>EOI</code>, <em>End of Input</em>), а был обнаружен текущий символ.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = !&#39;g&#39; &#39;foo&#39;</span>
<span class="nx">seqnc</span><span class="p">(</span><span class="nx">not</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)),</span> <span class="nx">match</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">))();</span> <span class="c1">// == [ &#39;&#39;, &#39;foo&#39; ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="seqnc">10. <code>seqnc</code></h2>
<p><strong>Описание:</strong> Вычислить несколько операторов в порядке очереди, вернуть результаты их выполнения обёрнутыми в массив.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&lt;выражение1&gt; &lt;выражение2&gt; ...</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">seqnc</span><span class="p">(</span><span class="cm">/*f...*/</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">ppos</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">,</span>
      <span class="nx">s</span> <span class="o">=</span> <span class="p">[],</span>
      <span class="nx">on_miss</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">pos</span> <span class="o">=</span> <span class="nx">ppos</span><span class="p">;</span> <span class="k">throw</span> <span class="nx">e</span><span class="p">;</span> <span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">fi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">fl</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
        <span class="nx">fi</span> <span class="o">&lt;</span> <span class="nx">fl</span><span class="p">;</span> <span class="nx">fi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">safe</span><span class="p">(</span><span class="nx">fs</span><span class="p">[</span><span class="nx">fi</span><span class="p">],</span> <span class="nx">on_miss</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Принимает список операторов в качестве параметров (их может быть неограниченное количество, благодаря использованию <code>arguments</code>) — сохраняет его в переменной <code>fs</code>. Сохраняет <em>локально</em> текущую позицию парсинга в переменной <code>ppos</code>. <code>s</code> — массив, в который будут собраны результаты выполнения переданных операторов.</p>

<p>Итерируясь по списку операторов, выполняет каждый в безопасном окружении с помощью функции <code>safe</code>, которая передаёт первое же перехваченное исключение в функцию <code>on_miss</code>, которая, в свою очередь, предварительно отматывает позицию парсинга назад, а потом выбрасывает то же самое исключение (выполнение операторов влияет на позицию).</p>

<p>Если исключений поймано не было, возвращает массив результатов.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = . &#39;oo&#39;</span>
<span class="nx">seqnc</span><span class="p">(</span><span class="nx">ch</span><span class="p">(),</span> <span class="nx">match</span><span class="p">(</span><span class="s1">&#39;oo&#39;</span><span class="p">))();</span>
<span class="c1">// == [ &#39;f&#39;, &#39;oo&#39; ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="choice">11. <code>choice</code></h2>
<p><strong>Описание:</strong> Проверить, совпадает ли входная строка с текущей позиции с одним из перечисленных выражений. Если да — вернуть совпадение, если нет — сообщить о неудаче парсинга.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&lt;выражение1&gt; / &lt;выражение2&gt; / ...</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">choice</span><span class="p">(</span><span class="cm">/*f...*/</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">,</span>
      <span class="nx">missed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">my_e</span> <span class="o">=</span> <span class="kc">null</span><span class="p">,</span>
      <span class="nx">on_miss</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="nx">my_e</span> <span class="o">=</span> <span class="nx">e</span><span class="p">;</span> <span class="nx">missed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">fi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fl</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
       <span class="nx">fi</span> <span class="o">&lt;</span> <span class="nx">fl</span><span class="p">;</span> <span class="nx">fi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">safe</span><span class="p">(</span><span class="nx">fs</span><span class="p">[</span><span class="nx">fi</span><span class="p">],</span> <span class="nx">on_miss</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">missed</span><span class="p">)</span> <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="nx">missed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">throw</span> <span class="nx">my_e</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Принимает список операторов в качестве параметров (их может быть неограниченное количество, благодаря использованию <code>arguments</code>) — сохраняет его в переменной <code>fs</code>. Подготавливает функцию <code>on_miss</code>, которая устанавливает флаг <code>missed</code> в единицу.</p>

<p>Итерируясь по списку операторов, выполняет каждый в безопасном окружении с помощью функции <code>safe</code>, которая передаёт первое же перехваченное исключение в функцию <code>on_miss</code>, которая, в свою очередь, устанавливает флаг <code>missed</code> в единицу и сохраняет последнее исключение. Если исключения для текущего оператора не было выброшено (<code>missed</code> равен нулю), значит совпадение найдено и можно вернуть результат выполнения этого оператора. Сбрасывает флаг <code>missed</code> в ноль для следующей итерации цикла.</p>

<p>Если ни один из операторов не выполнился удачно, выбрасывает последнее исключение (внутренними средствами парсера, не приведёнными здесь (функция <code>failed</code>), в метаданных исключения были накоплены все не совпавшие варианты).</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = . (&#39;aa&#39; / &#39;oo&#39; / &#39;ee&#39;) .</span>
<span class="nx">seqnc</span><span class="p">(</span><span class="nx">choice</span><span class="p">(</span><span class="nx">ch</span><span class="p">(),</span> <span class="nx">match</span><span class="p">(</span><span class="s1">&#39;aa&#39;</span><span class="p">),</span> <span class="nx">match</span><span class="p">(</span><span class="s1">&#39;oo&#39;</span><span class="p">),</span> <span class="nx">match</span><span class="p">(</span><span class="s1">&#39;ee&#39;</span><span class="p">)))();</span>
<span class="c1">// == [ &#39;f&#39;, &#39;oo&#39; ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="action">12. <code>action</code></h2>
<p><strong>Описание:</strong> Выполнить переданное выражение, но вместо совпадения вернуть результат выполнения JavaScript-кода. Если проверка на совпадение была неудачной или код вернул <code>null</code>, сообщить об ошибке парсинга.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&lt;выражение&gt; { &lt;javascript-код&gt; }</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">action</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">inctx</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ppos</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">;</span> <span class="kd">var</span> <span class="nx">res</span><span class="p">;</span>
    <span class="nx">f</span><span class="p">();</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">code</span><span class="p">(</span><span class="nx">cctx</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">res</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="nx">pos</span> <span class="o">=</span> <span class="nx">ppos</span><span class="p">;</span>
      <span class="nx">failed</span><span class="p">(</span><span class="nx">SOMETHING</span><span class="p">,</span> <span class="nx">NOTHING</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Принимает оператор <code>f</code> и пользовательский код <code>code</code>. Всё тело оператора выполняется внутри собственном контексте a.k.a. области видимости (дочерней к той, из которой он был вызван) — этому способствует функция <code>inctx</code> (от <em>in context</em>).</p>

<p>Текущая позиция парсинга сохраняется как предыдущая: из пользовательского кода можно вызвать служебные функции, которые возвращают позицию, с которой был начат парсинг текущего оператора <code>action</code> (<code>offset</code>), номер строки (<code>line</code>) и колонки (<code>column</code>) для этой позиции или совпавший отрезок строки (<code>text</code>).</p>

<p>Затем выполняется оператор <code>f</code> (если он выбрасывает своё исключение <code>MatchFailed</code>, парсинг полностью прекращается). Возвращённое им значение <em>не</em> сохраняется. После него выполняется пользовательский код, принимая текущий уровень контекста <code>cctx</code> (в этой переменной хранятся именованные значения, доступные на текущем уровне контекста, а переменные внешних контекстов доступны по цепочке его прототипов), и если он вернул <code>null</code>, позиция парсинга возвращается в предыдущее состояние (выполнение операторов влияет на позицию) и с помощью функции <code>failed</code> выбрасывается исключение <code>MatchFailed</code> с сообщением, что ожидалось хотя бы что-то (маркер <code>SOMETHING</code>), а не обнаружилось ничего (маркер <code>NOTHING</code>).</p>

<p>Если код вернул некий результат, тот мирно возвращается из оператора.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = &#39;fo&#39; (. { return offset(); })</span>
<span class="nx">seqnc</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s1">&#39;fo&#39;</span><span class="p">),</span> <span class="nx">action</span><span class="p">(</span><span class="nx">ch</span><span class="p">(),</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">offset</span><span class="p">();</span> <span class="p">})();</span>
<span class="c1">// == [ &#39;fo&#39;, 2 ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="pre">13. <code>pre</code></h2>
<p><strong>Описание:</strong> Выполнить переданный код и вернуть пустую строку, если код вернул истину (или что угодно, что JavaScript посчитает за истину). Иначе сообщить об ошибке парсинга.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&amp; { &lt;javascript-код&gt; }</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">pre</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ppos</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">code</span><span class="p">(</span><span class="nx">cctx</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;&#39;</span> <span class="o">:</span> <span class="nx">failed</span><span class="p">(</span><span class="nx">cc</span><span class="p">(),</span> <span class="nx">EOI</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Предварительно приравнивает <em>глобальную</em> предпозицию парсинга к текущей.</p>

<p>Принимает пользовательский код <code>code</code>. В виду того, что для выполнения этого кода не нужен никакой дополнительный внутрений контекст кроме того, в котором он уже находится, если находится вообще — код выполняется без обиняков, принимая в качестве параметра текущий уровень контекста <code>cctx</code> (в этом объекте хранятся именованные значения, доступные на текущем уровне контекста, а переменные внешних контекстов доступны по цепочке его прототипов).</p>

<p>Возвращает пустую строку если код вернул истинное значение; или сообщает о неудаче парсинга с пояснением, что ожидался текущий символ, а был обнаружен конец ввода (маркер <code>EOI</code>, <em>End of Input</em>), если значение было ложным.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = &amp;{ return true; } &#39;foo&#39;</span>
<span class="nx">seqnc</span><span class="p">(</span><span class="nx">pre</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}),</span> <span class="nx">match</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">))();</span>
<span class="c1">// == [ &#39;&#39;, &#39;foo&#39; ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="xpre">14. <code>xpre</code></h2>
<p><strong>Описание:</strong> Выполнить переданный код и вернуть пустую строку, если код вернул ложь (или что угодно, что JavaScript посчитает за ложь). Иначе сообщить об ошибке парсинга.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>! { &lt;javascript-код&gt; }</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">xpre</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ppos</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">code</span><span class="p">(</span><span class="nx">cctx</span><span class="p">)</span> <span class="o">?</span> <span class="nx">failed</span><span class="p">(</span><span class="nx">cc</span><span class="p">(),</span> <span class="nx">EOI</span><span class="p">)</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Предварительно приравнивает <em>глобальную</em> предпозицию парсинга к текущей.</p>

<p>Принимает пользовательский код <code>code</code>. В виду того, что для выполнения этого кода не нужен никакой дополнительный внутрений контекст кроме того, в котором он уже находится, если находится вообще — код выполняется без обиняков, принимая в качестве параметра текущий уровень контекста <code>cctx</code> (в этом объекте хранятся именованные значения, доступные на текущем уровне контекста, а переменные внешних контекстов доступны по цепочке его прототипов).</p>

<p>Возвращает пустую строку если код вернул ложное значение; или сообщает о неудаче парсинга с пояснением, что ожидался текущий символ, а был обнаружен конец ввода (маркер <code>EOI</code>, <em>End of Input</em>), если значение было истинным.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = !{ return false; } &#39;foo&#39;</span>
<span class="nx">seqnc</span><span class="p">(</span><span class="nx">xpre</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}),</span> <span class="nx">match</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">))();</span>
<span class="c1">// == [ &#39;&#39;, &#39;foo&#39; ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="label">15. <code>label</code></h2>
<p><strong>Описание:</strong> Сохранить результат вычисления переданного выражения в текущем контексте под указанным именем.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&lt;имя&gt;:&lt;выражение&gt;</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">label</span><span class="p">(</span><span class="nx">lbl</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">cctx</span><span class="p">[</span><span class="nx">lbl</span><span class="p">]</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>В объекте <code>cctx</code> хранятся именованные значения, доступные на текущем уровне контекста, а переменные внешних контекстов доступны по цепочке его прототипов.</p>

<p>Записывает результат вычисления переданного оператора <code>f</code> в объект <code>cctx</code> под указанным именем <code>lbl</code>.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = a:. &#39;oo&#39; { return a + &#39;bb&#39;; }</span>
<span class="nx">action</span><span class="p">(</span><span class="nx">seqnc</span><span class="p">(</span><span class="nx">label</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="nx">ch</span><span class="p">()),</span> <span class="nx">match</span><span class="p">(</span><span class="s1">&#39;oo&#39;</span><span class="p">)),</span>
       <span class="kd">function</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="s1">&#39;bb&#39;</span> <span class="p">})();</span>      <span class="c1">// == &#39;fbb&#39;</span>
</pre></div>
</td></tr></table></div></div><h2 id="section-5">16. Правило</h2>
<p><strong>Описание:</strong> Именованное правило парсинга, позволяет ссылаться на данное правило из других правил, содержит неограниченное число выражений-операторов.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&lt;имя_правила&gt; = &lt;выражения&gt;</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nx">rules</span><span class="p">.</span><span class="o">&lt;</span><span class="nx">имя_правила</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">код_корневого_оператора</span><span class="o">&gt;</span><span class="p">)();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>Содержимое любого правила в AST-дереве автоматически оборачивается в корневой оператор (если оно содержит одно выражение, то это оператор этого выражения, если несколько — оператор <code>seqnc</code>). Поэтому вызов правила эквивалентен вычислению и возвращению значения этого оператора.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// PEG: space = &quot; &quot;</span>
<span class="nx">rules</span><span class="p">.</span><span class="nx">space</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">))();</span> <span class="p">}</span>
<span class="c1">// PEG: foo = . . .</span>
<span class="nx">rules</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="nx">seqnc</span><span class="p">(</span><span class="nx">ch</span><span class="p">(),</span> <span class="nx">ch</span><span class="p">(),</span> <span class="nx">ch</span><span class="p">()))();</span> <span class="p">}</span>
<span class="c1">// PEG: foo &quot;bar&quot; = . &#39;o&#39;+</span>
<span class="nx">rules</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="nx">as</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span>
                                    <span class="nx">seqnc</span><span class="p">(</span><span class="nx">ch</span><span class="p">(),</span> <span class="nx">some</span><span class="p">(</span><span class="nx">match</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)))</span>
                                   <span class="p">))();</span> <span class="p">}</span>
<span class="c1">// input = &#39;foo&#39;</span>
<span class="nx">rules</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// == [ &#39;f&#39;, [ &#39;o&#39;, &#39;o&#39; ] ]</span>
</pre></div>
</td></tr></table></div></div><h2 id="ref">17. <code>ref</code></h2>
<p><strong>Описание:</strong> Используется для вызова указанного правила в данной позиции парсинга.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&lt;имя_правила&gt;</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">ref</span> <span class="o">=</span> <span class="nx">inctx</span><span class="p">;</span>
</pre></div>
</td></tr></table></div></div>
<p>Эквивалентно вызову корневого оператора правила в его собственном контексте, поэтому приравнивается фукнции <code>inctx</code>, которая при вызове оператора создаёт внутренний уровень контекста и присваивает его переменной <code>cctx</code>.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start = fo_rule &#39;o&#39;</span>
<span class="c1">//      fo_rule = &#39;fo&#39;</span>
<span class="nx">rules</span><span class="p">.</span><span class="nx">start</span> <span class="o">=</span> <span class="nx">seqnc</span><span class="p">(</span><span class="nx">ref</span><span class="p">(</span><span class="nx">rules</span><span class="p">.</span><span class="nx">fo_rule</span><span class="p">),</span> <span class="nx">match</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">));</span>
<span class="nx">rules</span><span class="p">.</span><span class="nx">fo_rule</span> <span class="o">=</span> <span class="nx">match</span><span class="p">(</span><span class="s1">&#39;fo&#39;</span><span class="p">);</span>
<span class="nx">rules</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span> <span class="c1">// == [ &#39;fo&#39;, &#39;o&#39; ];</span>
</pre></div>
</td></tr></table></div></div><h2 id="as">18. <code>as</code></h2>
<p><strong>Описание:</strong> Выполнить правило под другим именем. Влияет только на вывод ошибки парсинга.</p>

<p><strong>Синтаксис в грамматике:</strong> <code>&lt;имя-правила&gt; &quot;&lt;алиас&gt;&quot; = &lt;выражения&gt;</code></p>

<p><strong>Код:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">as</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alias</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span> <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>
  <span class="nx">alias</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span> <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div></div>
<p>На время выполнения оператора <code>f</code> (структура AST-дерева гарантирует, что это будет корневой оператор правила) подменяет имя текущего правила (глобальная переменная <code>alias</code>) на переданное, затем возвращает результат. Если во время выполнения оператора произошла ошибка парсинга, в описании этой ошибки будет содержаться указанное имя правила.</p>

<p><strong>Пример:</strong></p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
<span class="c1">// PEG: start &quot;blah&quot; = &#39;bar&#39;</span>
<span class="nx">as</span><span class="p">(</span><span class="s1">&#39;blah&#39;</span><span class="p">,</span> <span class="nx">match</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">))();</span>
<span class="c1">// MatchFailed: Expected blah, but &#39;f&#39; found</span>
</pre></div>
</td></tr></table></div></div><h1 id="section-6">Эпилог</h1>
<p>Вот и подошло к концу наше увлекательнейшее путешествие в мир операторов парсинга, дорогой друг. Надеюсь, эта статья заставила тебя призадуматься об альтернативных путях парсинга окроме общеизвестных, а также понять, чем грозит их использование <a href="https://gist.github.com/shamansir/7346436">на реальных примерах</a>, чуть менее недооценивать JavaScript и чуть менее переоценивать Хаскель. Спокойной ночи и хорошего рабочего дня тебе, дорогой друг.</p>

<p>И да, можешь погенерировать функциональных парсеров <a href="http://shamansir.github.io/pegjs-fn/">онлайн</a>, если хочешь. А если тебя расстраивает факт черепашьей скорости моих функциональныx парсеров, я вовсе не против если ты поиграешься с <a href="http://pegjs.majda.cz/online">оригинальной нефункциональной версией</a>.</p>

<p>На сим прощаюсь, твой шаман.сэр.</p>

        </div>
    </article>

    </section>

    
        <ul id="nwao-social">
    <li><a href="https://twitter.com/#!/shaman_sir" title="профиль в Twitter"><img src="/blog/ru/assets/img/social/twitter.png" width="16" height="16" alt="профиль в Twitter"></a></li>
    <li><a href="https://github.com/shamansir" title="профиль в Github"><img src="/blog/ru/assets/img/social/github.png" width="16" height="16" alt="профиль в GitHub"></a></li>
    
    <li><a href="https://www.facebook.com/shaman.sir" title="профиль в Facebook"><img src="/blog/ru/assets/img/social/facebook.png" width="16" height="16" alt="профиль в Facebook"></a></li>
    
    
    <li><a href="http://stackoverflow.com/users/167262" title="профиль в Stackoverflow"><img src="/blog/ru/assets/img/social/stack-overflow.png" width="16" height="16" alt="профиль на Stack Overflow"></a></li>
    
</ul>
    

    <div id="nwao-jump-to-top"><a href="#top" title="Наверх">Наверх</a></div>

    <footer id="nwao-footer">
        <p>Copyright &copy; 2017 Ulric Wilfred; запитано <a href="http://mynt.mirroredwhite.com/" title="mynt">mynt</a> и <a href="http://input.fontbureau.com/" title="шрифты Input">шрифтами Input</a></p>
    </footer>

    <!--
    <script type="text/javascript" src="/blog/ru/assets/js/scrolls.js"></script>
    <script type="text/javascript" src="/blog/ru/assets/js/page.scrolls.js"></script> -->

</body>
</html>