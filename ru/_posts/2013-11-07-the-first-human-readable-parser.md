---
layout: post.html
title: (возможно) Первый в мире генератор читабельных, хоть и чрезвычайно медленных, парсеров на JS
datetime: 07 Nov 2013 08:14
tags: [ functions, javascript ]
---

Если ты меня вообще помнишь, читатель — то, наверняка, помнишь и то, что мои посты в подавляющем количестве случаев разочарующе длинны и довольно-таки часто им предшествует лирическая предыстория. Заверяю тебя, этот пост отнюдь не исключение — я настолько же надёжный графоман, как и ранее, а то ещё и более закалённый.

По сходным обстоятельствам, мало что из описанного в тех постах было доведено до идеального состояния и они, скорее, содержали общие предпосылки к размышлениям, нежели описывали законченный продукт — хотя, преимущественно много внимания всегда было уделено использовавшимся решениям. И по этому пункту я не менее верен тебе и сейчас, дорогой читатель.

Как и раньше, в посте будет множество ссылок и отрывков исходного кода.

Всё как в старые добрые времена. Добро пожаловать, друг.

# Обширная предыстория

Не знаю, что конкретно ударило мне в голову года эдак два назад, но мне сильно не понравились существующие на тот момент парсеры Markdown, написанные на JS. Ты удивлён, не так ли?

Например, они не умели рендерить блоки кода в субэлементах списков элементов надсписков, а также что-то из расширенного маркдаун-синтаксиса, что лишь мне и было нужно. И ещё, вообще уже не помню зачем, я очень хотел вызывать различный JS-код в качестве реакций на удачные совпадения с правилами.

Поскольку я любитель активно генерализировать задачи, я нашёл отличный генератор JS-парсеров [PEG.js](http://pegjs.majda.cz/), потом нашёл [GUI-ориентированную библиотеку по подсветке markdown-синтаксиса на C++](http://hasseg.org/peg-markdown-highlight/) (которая используется в бесплатном, стильном и прекрасном Mac-OS-приложении для редактирования Markdown, не в пример мне кратко именующем себя [Mou](http://mouapp.com/)), из которого я выдрал [LEG-грамматику Markdown](https://github.com/ali-rantakari/peg-markdown-highlight/blob/master/pmh_grammar.leg) (которая, в свою очередь была модифицирована из [грамматики Джона МакФерлейна](http://web.archive.org/web/20131116073646/https://github.com/jgm/peg-markdown/blob/master/markdown_parser.leg)) и начал адаптировать всю эту портянку под PEG.js, параллельно её улучшая.

Чем [всё это](https://github.com/shamansir/mdown-parse-pegjs) кончилось? Лишь тем, что я запомнил имя Ali Rantakari, автора библиотеки подсветки синтаксиса, минимум на два года с хвостиком. Не потому что он в чём-либо виноват, а просто вот так вот вышло.

Если взять глубже, всё вышеописанное зашло в свой локальный тупик в тот безрадостный момент, когда я увидел что сгенерированный парсер занимал просто неуважительные для меня 6МБ (по памяти эта цифра может быть воспроизведена неточно, но масштаб трагедии, я думаю, должен быть нагляден; да и вообще, почему-то в голове у меня крутится цифра **24**) неминифицированного JavaScript-кода. Минифицированного — не сильно меньше. Да-да, читатель, ты не ошибся, парсер какого-то (_TODO:_ пометить красным) вшивенького маркдауна, и **6МБ** — это ни в какие ворота.

Тогда мне не особо рассказывали, что генерируемые парсеры таким грешат и код в них отнюдь не обязан быть оптимальным, а преимущественно являётся результатом поэлементной развёртки правил. И что размер не обязательно пропорционален скорости парсинга, даже таким вот трудноподъёмным парсером. Вернее, может и рассказывали, но, признайся мне, что может быть более весёлого в жизни, чем гнуть свою линию.

И, так как мне такого не рассказывали, я очень возмутился — очень много было неоптимальных, с точки JS-программиста, кусков кода в этом парсере, а ещё даже более раздражали Java-подобные имена функций в коде. Вот прям нет сил терпеть. Я даже пример того кода приводить не буду, прошу поверить мне на слово (на самом деле вот отреставрированный вариант, сгенерированный PegJS версии двухгодичной давности, но почему-то в шесть раз меньше по размеру, возможно из-за того что версия недостаточно ранняя ;) ). А вот сравнение современного варианта оригинального PegJS и описываемой здесь модификации.

И я ещё раз перегенерализировал задачу — убедил себя, что не могу позволить себе не привести этот парсер в приличный функциональный вид. Чтобы, например, такое вот правило:

```peg
shakespeare = ("To" / "2") space "b" "e"? space
              ("or" / "|") space ("not" / "!") space
              ("to" / "2") space "b" "e"?
```

Генерировало такой вот парсер:

```javascript
rules.shakespeare = function() {
  return (
    seqnc(
      choice(match("To"), match("2")),
      ref(rules.space),
      match("b"), maybe(match("e")),
      ref(rules.space),
      choice(match("or"), match("|")),
      ref(rules.space),
      choice(match("not"), match("!")),
      ref(rules.space),
      choice(match("to"), match("2")),
      ref(rules.space),
      match("b"), maybe(match("e"))
    )
  ());
}
```

Или что-то вот такое абстрактное:

```
foo = "x"+ a:("-" c:some_rule { return c; })? { return a; }
```

Генерировало такой:

```javascript
rules.foo = function() {
  return (
    action(
      seqnc(
        some(
          match("x")
        ),
        label("a",
          maybe(
            action(
              seqnc(
                match("-"),
                label("c",
                  ref(rules.some_rule)
                )
              ),
              function() { return c; }
            )
          )
        )
      ),
      { return a; }
    )
  ());
}
```

На мой двуглазый взгляд любой лиспер поймёт, как работает приведённый код, если даже оставит открытым один лишь третий глаз. И закроет оба моих.

Такова была цель, и, надеюсь, ты согласишься, как идея она была достаточно красива.

… И вполне исполнима. Спустя аж джва с лишним года, её реализация у меня таки **_вышла_**! Не скажу, что я прямо так уж сильно торопился, я периодически вообще забрасывал это дело и преключался на другие, немногим более перспективные, а то и вообще уходил в запой. Тем не менее, два года, вечерами, я по крупинке ковырял код и тесты просто ради того, чтобы чем-то себя занять. Продумывал оптимизации и «операторы» в неподходящих жизненных ситуациях, в непредназначающихся обстановках, в неположенное время — точно так, как делает любой уважающий себя нерд.

Это хорошие новости. Но, как всегда, нашлись и плохие. И, конечно же грустные. Приведу [статистику](https://gist.github.com/shamansir/7346436) (как только gist выдержал эти килограммы?):

* [css.pegjs](https://github.com/dmajda/pegjs/blob/master/examples/css.pegjs) — исходная грамматика

    * _размер:_ 13.4кБ
    * _строк:_ 552 ± 15 на комментарии

* [css.old_pegjs.parser.js](https://gist.github.com/shamansir/7274681#file-css-old_pegjs-parser-js) — парсер, сгенерированный оригинальной версией PEG.js двухгодичной давности, коммит 4f86fca3d7

    * _размер:_ **367кБ**
    * _строк:_ 11,378 ± 15 на комментарии,
    * _парсинг [файла](https://github.com/dmajda/pegjs/blob/master/benchmark/css/blueprint/min/screen.css) размером 11.8кБ x 10 раз:_ **11.60мс**

* [css.cur_pegjs.parser.js](https://gist.github.com/shamansir/7274681#file-css-cur_pegjs-parser-js) — парсер, сгенерированный текущей оригинальной версией PEG.js,

    * _размер:_ **334кБ**,
    * _строк:_ 11,225 ± 15 на комментарии,
    * _парсинг [файла](https://github.com/dmajda/pegjs/blob/master/benchmark/css/blueprint/min/screen.css) размером 11.8кБ x 10 раз:_ **19.40мс**

* [css.pegjs_fn.parser.js](https://gist.github.com/shamansir/7274681#file-css-cur_pegjs_fn-parser-js) — парсер, сгенерированный моей текущей версией PEG.js-FN,

    * _размер:_ **107кБ**,
    * _строк:_ 4,452 ± 200 на комментарии (у меня много комментариев и там много чего свернуть можно),
    * _парсинг [файла](https://github.com/dmajda/pegjs/blob/master/benchmark/css/blueprint/min/screen.css) размером 11.8кБ x 10 раз:_ **561.60мс**

То есть при не-особо-сильной экономии на размере, скорость увеличилась не просто кардинально, а катастрофически (в 30 раз относительно текущей версии). Можно свалить на частный случай парсера, JSON-парсер парсит всего в 5-20 раз дольше оригинала, но к сожалению скорость парсинга увеличивается экспоненциально относительно размера парсящегося файла (как ты думаешь, читатель, может это подсказка?).

Но я пока ещё ничего не оптимизировал. Вообще. Даже не брался.

Отдельная беда в том, что автор PEG.js, [David Majda](http://majda.cz/), пока я ковырялся со своей версией, перевёл всё своё хозяйство на псевдо-байткод (статистика выше, тем не менее, представлена именно с байткодовой версией). Нет, безусловно я следил за тем, что там происходит, и исправно обновлял тесты на новые. Но я хотел добиться своего результата, так как вообще не с чем было даже сравнить, чтобы оценить уровень бесполезности моей идея. Кстати, 469 тестов, это вам не хухры-мухры. Очень приятно смотреть, как они все проходят. Особенно после моментов, когда до этого бывало такое, что в десятый раз исправляешь три теста и начинают валиться пятьдесят. Впрочем, тебя таким не удивить.

Однако, как видишь, дорогой читатель, все означенные расстройства не остановили меня от написания статьи. Если бы можно было принять критерием читабельность кода парсера, я бы поделил скорость парсинга на его значение, тем самым уменьшив его в 200 раз, и стал бы окончательно счастлив. Кстати, [Никита](https://twitter.com/dudnik), благодарю за подбадривание с самого начала этой истории.

Оптимизацию я наметил на будущее, может быть что-то и выйдет. Но сейчас никак нельзя останавливаться.

Ибо в процессе, как я считаю, я изобрёл **_Функциональные Операторы Парсинга_** (если только их ещё не придумали в Хаскеле — иначе я сильно опоздал и остаётся лелеять надежду на туманный шанс запатентовать прелестный термин).

О них и пойдёт речь.

Ах да, все исходники — в моём проекте [PEG.js-FN](https://github.com/shamansir/pegjs-fn) на гитхабе.

# Структура парсера

В парсерах, сгенерированных PEGjs-FN (в отличие, кстати, от оригинала [по крайней мере, на данный момент]), пользовательский код чётко отделяется от кода самого парсера собственной областью видимости.

«Что за пользовательский код?», — спросишь ты.

В PEG.js есть замечательная возможность заключить любую часть правила грамматики в скобки и выполнить некий JS-код, если эта часть совпала с исходной строкой. При этом в JS-коде, в виде переменных, доступны все предшествующие именованные совпадения, находящиеся на том же уровне контекста или выше. Эти «совпадения» также могут скрывать под собой другой JS-код, по такому же принципу возвращающий и выполняющий всё, что программисту угодно.

Возьмём пример выше:

```peg
foo = "x"+ a:("-" c:some_rule { return c; })? { return a; }
```

Если ты знаком с PEG-грамматикой, то ты всё понял. Если нет — то нет, но не отчаивайся, я попробую объяснить.

Здесь совпадение с именем a должно бы было возвращать символ "-", конкатенированный с результатом парсинга по правилу `some_rule` — но действие этого совпадения _переопределено_ и оно возвращает только результат парсинга по правилу `some_rule`. Тем же образом, совпадение по правилу `foo` в данном случае возвращает не набор символов «x», конкатенированных с результатом парсинга по последовательности `a` — а лишь результат парсинга по последовательности `a`. А могло и запустить искуственный интеллект, который вернул бы новейший сонет Шекспира.

Кроме того, PEG.js предоставляет и другую замечательную возможность: предварить весь парсер неким глобальным (для парсера) JS-кодом, который, следовательно, будет доступен всем таким блокам кода. В PEG.js такой код именуется _инициализатором_.

Совокупность описанных возможностей и есть _пользовательский код_ — по сути, любой JS-код, содержащийся в грамматике.

Итак, структура:

```javascript
(function() {

 // общие для пользовательского кода и парсера переменные
 var input, ppos, pos;

 // весь пользовательский код, изолированный от кода парсера
 var __user_code = function() {

   // функции, предоставляемые пользователю парсером
   function offset(), function text(), ...

   // инлайн-код пользовательского инициализатора
   function PARSE_ME_BABY...
   function SHIT_THAT_KILLED_ELVIS...

   return {
     // сгруппированные по имени правила блоки пользовательского кода
     foo: [ function(ctx) { return (function(c) { return c; })(ctx.c); },
            function(ctx) { return (function(a) { return a; })(ctx.a); }  ]
     ...
   }

 };

 // код парсера, изолированный от пользовательского кода
 return (function() {

   // переменные, доступные только правилам, операторам и парсеру
   var code, rules = {};

   // код правил, входящих в данный парсер
   rules.foo = function() { var code = code.foo;
                            return action(seqnc(...))(code[1]); }
   rules.start = rules.foo;

   // все использующиеся в парсере операторы
   // (неиспользующиеся не включаются)
   function action() { ... }
   function seqnc() { ... }
   function match() { ... }
   ...

   // парсеро-независимые утилиты и хелперы
   ...

   return {
     ...
     parse: function(_input) {
        input = _input;
        code = __user_code();
        return rules.start();
     }
   }

 })();

})();
```

Довольно просто, не правда ли? :)

# Пояснения

Области видимости операторов в парсере реализованы через цепочки прототипов JS, то есть на каждую вложенную область видимости создаётся JS-объект, свойства которого хранят текущую область видимости, а прототип указывает на родительскую область видимости. Возможно, этот факт тоже пагубно влияет на скорость.

Все результаты выполнения правил кэшируются по ключу «имя правила + позиция во входной строке», как и в оригинале.

При неудачном парсинге выбрасывается исключение `MatchFailed`, которое, если не было перехвачено, снабжается дополнительной информацией, вроде двумерных координат неудачи (строка: столбец), и выдаётся пользователю.
