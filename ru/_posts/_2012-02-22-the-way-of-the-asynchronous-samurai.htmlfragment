<p>JavaScript — очень необычный язык. Может это звучит немного странно, но по-моему в его истории есть некоторое сходство с судьбой японского языка. Он, возможно, не был изначально глубоко продуман и был сделан на скорую руку, но при этом в умелых руках он часто оказывается неожиданно элегантным. Он был &ldquo;поскрёбан&rdquo; по различной степени качества сусекам, но при этом он легко впитывает нововведения и иногда даже кажется, что только для них и был создан. Он покорно принимает различные стили письма и, если бы не апологеты, &ldquo;правильное&rdquo; написание было бы, возможно, уже забыто… И, самое главное, как и для японского, <em>нет обозримой границы в познании этого языка</em>.не Я знаком с ним на протяжении многих лет и он постоянно открывает мне новые грани.</p>

<p>Но одно я знаю точно — на JavaScript можно писать очень простой и понятный код. К этому нужно стремиться и взращивать это в себе, нужно не опускать руки, нужно узнавать новые и новые вещи, уметь принимать их, и рано или поздно обнаруживаешь, что сам язык — довольно-таки прост и при этом очень, просто-таки бесконечно, элегантен.</p>

<p>И впитывает новое, как губка.</p>

<habracut />

<p>Теперь к делу.</p>

<h2>Проблема</h2>
<p>Большинство жалоб на язык — ООП, которое, <a href="http://shamansir.github.com/js-lecture-wsd">как известно</a>, в нём есть, в своём наипрекраснейшем и буквальном виде, в виде прототипов. И даже необходимость в наследовании оказывается довольно-таки надумана, когда понимаешь, как дружить миксины. Но статья, в этот раз, не об этом.</p>

<p>Вторая по категоричности, но первая по сегодняшней моде, жалоба — &ldquo;неудобство асинхронного программирования&rdquo;. Она озвучивается тут и там, находят способы один необычнее другого, но все они ненамного проще друг друга настолько, что мне даже не хочется приводить ссылки (хотя приведу пример). Предлагаются сотни похожих библиотек, пишутся монструозные заменители, в общем всё происходит так, как обычно происходит с бедным стареньким, молодым и свежим JavaScript'ом.</p>

<p>…И потом пишутся тонны &ldquo;образумливающих&rdquo; статей подобных моей, и только читателю решать, где истина.</p>

<p>Посему эта статья о том, как <em>сделать асинхронное программирование действительно простым</em>. Но добиться настоящей простоты обычно довольно-таки сложно, поэтому, чую, статья получится вполне объёмной.</p>

<p>В обратном порядке, от не очень приятного метода до самого клёвого и независимого (от того, node.js вы используете или браузерный движок), поэтому я вам даже советую <a href="#point-5"><em>просто проскроллить вниз</em></a>. Кроме того, последние пункты немного разъяснят как работают, например, библиотеки. …И сразу же пример из него, чтобы уж точно никто не смущался: <em>семью</em> строками кода JS, без библиотек, мы добъёмся, например, этого:</p>

<source lang="javascript">safe_read(read_file('a'),
          read_file('b'),
          read_file('не_существует'),
          read_file('c') // эта, последняя, функция не будет вызвана (вообще!)
         );
</source>

<h2>Когда всё это нужно?</h2><ul><li>Цепочки запросов к серверному API</li>
<li>Необходимость последовательного извещения UI по сингалам с сервера, да и без сигналов тоже</li>
<li>Поочерёдное чтение файлов</li>
<li>Парсеры текста и парсер-генераторы</li>
<li>Аналоги консольного pipe (<code>|</code>) или направление символьных потоков</li>
<li>Чтение пользовательского ввода</li>
<li>Безопасные вызовы цепочек функций</li>
</ul><p> Цепочки, цепочки… Вы заметили, да?</p>
<p><a name="contents"></a></p>

<h2>Содержание</h2><ul>
<li><a href="#point-1">Путь 1. Просто вызовы</a></li>
<li><a href="#point-2">Путь 2. Шины событий</a></li>
<li><a href="#point-3">Путь 3. Библиотеки</a></li>
<li><a href="#point-4">Путь 4. «Чистые» монады</a></li>
<li><a href="#point-5">Путь 5. «Грязноватые» (но от этого такие простые) монады или «Мы можем это сами»</a></li></ul><p><a name="point-1"></a></p>

<h2>Путь 1. Просто вызовы</h2>

<p>Почти что первое, что приходит на ум.</p>

<p>Допустим, у вас есть серверное атомарное API, есть класс работы с ним и мы хотим получить сортированный список пользователей. Сильно не утруждайтесь разбираться, оцените только размер и сложность кода, это всё равно худший из вариантов (хотя в сети встречаются <em>ещё хуже</em>):</p>

<source lang="javascript">
var people = (function() {

  var papi = new PeopleAPI();

  function People() {
    this.__requested = false;
    this.__callback = null;
  }

  People.prototype.getAllSorted = function(callback) {
    if (this.__requested) throw new Error('Request already started');
    this.__requested = true;
    this.__callback = callback;
    papi.orderedBy('name', bind(this, this._gotOrder));
  }

  People.prototype._gotOrder = function(order) {
     var res = {}, got = 0;
     var got_one = (function(people, count) {
       return function(man) {
         res[man.id] = man;
         people.__got++;
         if (people.__got === count) {
           people._gotAll(order, res);
         }
       }
     })(this, order.length);
     for (var oi = 0, ol = order.length; oi &lt; ol, oi++) {
       papi.find(order[oi], got_one);
     }
  }

  People.prototype._gotAll = function(order, res) {
    this.__callback(order, res);
    this.__requested = false;
  }

  return new People(); 

})();
</source>
<p>В нужный момент мы передаём нужный метод-хэндлер, храним состояние вызова… Ох, всё равно до хрена монструозно, правда? <strong>Ужас, ужас!</strong> Мне даже сейчас было противно писать это и я ничего не тестировал, хотя когда-то похожим образом у меня был построен <a href="http://code.google.com/p/lepro-blackjack/source/browse/trunk/lepro-blackjack/blackjack.js#778">относительно крупный проект</a> (там выглядит чуть лучше, потому что API писал тоже я :) ). Пропускаем.</p>

<p><a name="point-2"></a></p>

<h2>Путь 2. Шины событий</h2>

<p>Попробуем быть чуть умнее, заведём общую шину событий:</p>

<source lang="javascript">var handlers = {
  'user': {}, 
  'book': {}, 
  'message': {},
  '_error': [] // допустим, ошибки не зависят от namespace
};

events = [ 'update', 'create', 'delete', 'list' ];

for (var ei = events.length; ei--;) {
  for (var ns in handlers) { // мой объект чист, поэтому не нужно `hasOwnProperty`
    handlers[ns][events[ei]] = [];
  }
};
</source>
<p>Шина событий в данном случае разбита на подразделы (области имён), а глубже уровнем подразделы разбиты на типы событий, где на данный момент содержатся пустые массивы. Например, <code>handlers.user.update</code> и <code>handlers.message.list</code> это пустые массивы (<code>[]</code>), и так для каждого события в каждом подразделе.</p>

<p>Теперь организуем функции подписки на события и ошибки и функции выброса (ну а как ещё назвать?) и тех и других.</p>

<source lang="javascript">// теперь объект handlers можно наполнять ссылками
// на "слушателей", группируя их по неймспейсу
// и типу события

// подписаться на событие в неймспейсе
function subscribe(ns, event, handler) {
  handlers[ns][event].push(handler);
}

// подписаться на сообщения об ошибках
function subscribe_errors(handler) {
  handlers._error.push(handler);
}        

// сообщить о произошедшем в неймспейсе сообытии
function fire(ns, event, e) {
  var e_handlers = handlers[ns][event],
      hname = 'on_'+ns+'_'+event,
      handler;
  for (var ei = e_handlers.length; ei--) {
    handler = e_handlers[ei][hname];
    handler.call(handler, e);
  }
}

// сообщить о произошедшей ошибке
function fire_error(err) {
  var e_handlers = handlers._error;
  for (var ei = e_handlers.length; ei--) {
    e_handlers[ei].on_error.call(handler, err);
  }
}
</source>
<p>По сути это весь необходимый код механизма событий и он, по-моему, довольно приличный. Так что без лишних рассуждений приведём пример использования:</p>

<source lang="javascript">// некий proxy к серверному API, 
// делает только асинхронные вызовы
var uapi = new UserAPI(); 

// ваше приложение
function MyApp {
  // TODO: сделать функцию subscribe_all('user', this)
  subscribe('user','list', this);
  subscribe('user','update', this);
  . . .
  subscribe_errors(this);
}
// запросить список пользователей
MyApp.prototype.requestUsers() = function() {
  uapi.get_all(function(order, res) {
    fire('user', 'list', {
      order: order, list: res
    });
  });
};
// обновить данные о пользователе 
// (может вызываться при отправке формы заполнения профиля)
MyApp.prototype.updateUser(user) = function() {
  uapi.save(user, function(user) {
    fire('user', 'update', user);
  }, funtion(err) {
    fire_error(err);
  });
};
// этот метод будет вызван при срабатывании события user/list
MyApp.prototype.on_user_list = function(order, list) {
  . . . // обновление UI
  . . . // при необходимости можно выбросить другое событие
}
// этот метод будет вызван при срабатывании события user/update
MyApp.prototype.on_user_update = function(user) {
  . . . // обновление UI
  . . . // при необходимости можно выбросить другое событие
}
// этот метод будет вызван при ошибке
MyApp.prototype.on_error = function(err) {
  . . . // нотификация об ошибке, паника, кони, люди
}
</source>
<p>Выглядит значительно более лаконично по сравнению с предыдущим примером и получается даже чем-то похоже на GWT, только в разы короче ;). На события может подписываться не один объект, а сколько угодно, для работы с серверным API — почти что идеальное решение.</p>

<p>Но для парсеров и последовательного чтения файлов — не совсем то. Теперь представим, что нам надоело, мы закрыли глаза, и обратились в сторону библиотек, не задаваясь вопросом что за ними стоит. Просто — взять и вставить, кого нынче волнуют килобайты и внутренности всяких этих хламидомонад?</p>

<p><a name="point-3"></a></p>

<h2>Путь 3. Библиотеки</h2>

<p>Как бы там ни было, по сравнению с другими популярно-предлагаемыми способами, библиотеки — не самое плохое решение. Хоть их и пишут сразу кучу по первой же надобности, некоторые из них отдельно хороши и в разы повышают качество вашего кода. Просто пара ссылок, думаю вы запросто сами разберётесь как их использовать:</p>
<ul>
<li><a href="https://github.com/kriskowal/q">Q</a> (node.js, browser)</li>
<li><a href="https://github.com/coolaj86/futures">Futures</a> (browser, node.js/v8, rhino)</li>
<li><a href="https://github.com/medikoo/deferred">deferred</a> (node.js, browser)</li>
<li><a href="https://github.com/laverdet/node-fibers">fibers</a> (node.js/v8)</li>
<li><a href="https://github.com/0ctave/node-sync">Sync</a> (node.js)</li>
<li><a href="https://github.com/caolan/async">Async</a> (node.js, browser)</li>
<li><a href="https://github.com/creationix/step">Step</a> (node.js)</li>
<li><a href="https://github.com/substack/node-seq">Seq</a> (node.js)</li>
</ul><p>Туда же пойдут Dojo.deferred и прочие кандидаты. Плюс, январская презентация <a href="http://www.medikoo.com/asynchronous-javascript/3d">«Аsynchronous JavaScript»</a> (англ.) от автора третьей библиотеки вдогонку.</p>

<p><a name="point-4"></a></p>

<h2>Путь 4. «Чистые» монады</h2>

<h4>モナダの空道</h4>

<p>…Ух ты, почти что ни одного упоминания о монадах в JS на русском, а я надеялся, мне не придётся их объяснять. Впрочем, я и не буду. И не будет в этой главе примеров кода «правильных» монад на JS. Англоязычных статей за последний год тысячи и в ближайшее время кто-нибудь их, да переведёт, и такого кода там завались:</p>
<ul>
<li><a href="http://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/">Translation from Haskell to JavaScript of selected portions of the best introduction to monads I’ve ever read</a></li>
<li><a href="http://igstan.ro/posts/2011-05-02-understanding-monads-with-javascript.html">Understanding Monads with JavaScript</a></li>
<li><a href="http://blog.jcoglan.com/2011/03/06/monad-syntax-for-javascript/">Monad Syntax for JavaScript</a></li>
<li><a href="http://amix.dk/blog/post/19509">How to build your own Monads</a></li>
<li><a href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">You could have invented monads</a></li>
<li><a href="http://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/">Promises are the monad of asynchronous programming</a></li>
<li><a href="http://matthew.yumptious.com/2009/04/javascript/dojo-deferred-is-a-monad/">Dojo.deferred is a monad</a></li>
<li><a href="http://importantshock.wordpress.com/2009/01/18/jquery-is-a-monad/">JQuery is monad</a></li>
<li><a href="http://stackoverflow.com/q/5569805/167262">Conjuring JQuery Deferred with monadic incantations</a></li>
<li><a href="http://sovety.blogspot.com/2009/09/haskell-horrors.html">(Новичковые) ужасы Хаскеля</a></li>
<li><a href="http://codereview.stackexchange.com/questions/8055/java-monad-implementation">Java Monad Implementation</a></li>
</ul>
<p>Но долг требует хотя бы вкратце изложить суть.</p>

<p>В разделе «Когда это нужно?» почти весь список содержал популярные примеры применения монад, причём распространено мнение, что вы можете использовать их часто даже сами не осознавая того, что вы их используете. (Знаю я этот приёмчик, слышал не раз). И монады, кстати, стары, как сам программистский мир.</p>

<p>…Однако восклик &ldquo;ах, блин, да это же монады, я ведь их часто использую&rdquo;, родился и у меня. Не супер, прямо скажем, часто, но, оказывается, правда случается. И это действительно ещё одна вещь  из того множества, которое надо понимать любому уважающему себя программисту.</p>

<p><em>Примечание:</em> К моему стыду, я очень плохо понимаю код на Haskell и как он работает, даже в двустрочных примерах, хоть и предпринимал пару решительных попыток залезть во вражеский лагерь. С другими языками программирования у меня обычно таких проблем нет (читаю за еду код на Java, Lisp, Python), а вот тут — обнаружилась. Посему мои последующие (до пятой главы) слова отнюдь не аксиомы, а лишь <em>то, что я увидел со своего берега</em>. Я могу даже нагло врать абсолютно не стесняясь (говорят, правда, что я этого не умею, но в тексте не должно быть заметно), но если вы вчитываетесь в эту главу, другого выхода у вас, на данный момент, нет :)</p>

<p>Всё просто. Если вы задались любой проблемой из вышеупомянутого списка из раздела «Когда это нужно?», значит вам нужны монады. И, как верно для любого паттерна, вы бы рано или поздно к ним пришли.</p>

<p>Они, в каких-то своих проявлениях, находятся среди вас — например, когда вы используете в консоли пайп:</p>

<source lang="bash">&gt; cat my.js | more
</source>
<p>Достаточно задуматься о том, как этот пайп написан, и вы тут же поймёте монады. Ну, не справочное описание, а именно как они <em>примерно</em> работают.</p>

<p>Если файл <code>my.js</code> не существует, <code>more</code> не будет вызван вообще. Это нам довольно знакомо, мы ведь со времён Perl любим писать:</p>

<source lang="javascript">&gt; read_file('my.js') || die('where\'s my file?!')
</source>
<p>Основная проблема в написании такого оператора — передача контекста. Вы не хотели бы знать, как работают <code>cat</code>, <code>more</code>, <code>read_file</code> или <code>die</code> (хотя снова вру, иногда очень даже интересно, что там, после этого <code>die</code>…). Вы бы скорее потребовали от них некий общий протокол общения, которому бы они беспрекословно следовали. Что-нибудь такое, что сделало бы очевидным, сорвалась операция или нет^ и готов для приёма абстрактный поток или не судьба.</p>

<p>Чтобы проблема была видна нагляднее, сделаем цепочку подлиннее, что-нибудь злобное (не пробовать дома, я и сам не пробовал):</p>

<source lang="bash">&gt; cat my.file &gt;&gt; /dev/dsp &gt;&gt; /dev/hda1 &gt;&gt; my_utility &gt;&gt; /dev/null
</source>
<p>Монада — это и элемент такой цепочки и одновременно функция, которая её обрабатывает.</p>

<p>«Чистая» монада должна быть полностью независимой от внешнего контекста, быть вещью в себе, но от неё требуется вернуть унифицированный ответ. При этом позволяется заставить её возвращать этот самый унифицированный ответ через всяческие функции-обёртки, но, ещё раз, для использования в цепочке <em>необходимо</em>, чтобы каждый элемент был унифицирован, вся цепочка должна работать по единому <em>правилу</em> и её элементы должны быть <em>компонуемы</em></p>

<p>В нашем, последнем представленном, случае, любой элемент (или сам контекст вызова) должен уметь оборвать выполнение всей цепочки, если хоть один элемент не доступен, и последовательно запрашивать новые куски потока, если всё хорошо. А для обеспечения корректной работы всего этого мы должны понять, произошла ошибка или нет и принудить все элементы передавать поток единообразно.</p>

<p>Вот этот момент, с ошибкой, является характерным примером монады <em>MayBe</em>, которую мы незаметно так рассмотрели: в некоторых языках (JavaScript среди них, so sad ;( ) нет специального типа для ошибки (временно забудем о <code>try</code>/<code>catch</code>) и мы не можем стопроцентно для всех случаев сказать, хотел нам пользователь намеренно вернуть <code>undefined</code>, <code>null</code> или <code>false</code> как некие пустые данные или он правда имел ввиду, что произошла ошибка. В шелле есть <code>exit code</code> и это однозначное сообщение об ошибке, так все эти пайпы и работают. И Хаскель тоже так умеет, а JavaScript вот — нет.</p>

<p>Так что монада — это некая функция, которая может быть вызвана в некой очереди, в дереве процессов или просто независимом контексте и, оставаясь для них прозрачной, способная адекватно сообщить о своём состоянии. Навскидку — так.</p>

<p>В Хаскеле все функции «чисты» и не изменяют что-либо вне себя (в смысле <em>вообще ничего</em>!), они работают исключительно с одним аргументом (другой функцией, <em>каррирование</em>) возвращаемым значением и лезть куда-то наружу для них —  святотатство. Поэтому почти любую функцию в Хаскеле можно «омонадить» (TODO: спросить Хаскелистов, похоже на правду это утверждение или нет), просто потому что она независима и прозрачна. Так рождаются различные комбинации монад.</p>

<p>Кроме <em>MayBe</em> (привязка точной информации об ошибке к оборачиваемой функции) существуют другие монады-паттерны: <em>Continuation</em> (связывание нескольких функций между собой), <em>Writer</em> (привязка текстовой информации к функции, например логгинга), <em>I/O</em> (спросить пользователя, дождаться ответа из терминала, отреагировать на ответ; или прочитать файл, дождаться когда он будет доступен, прочитать содержимое, закрыть файл), <em>Identity</em> (привязка/подмена информации в возвращаемом значении), <em>State</em> (привязка состояния к функции) и другие (смотрите ссылки в русской статье на википедии и раздел «Ссылки» статьи на английском).</p>

<p>То есть, как результат, несколько функций можно обернуть в <em>Continuation</em> (последовательный вызов) и для обеспечения требуемой унификации, для каждой можно использовать монаду <em>MayBe</em> и  как раз получится наш пайп или оператор <code>||</code> / <code>&amp;&amp;</code>.</p>

<p>Поэтому, когда вы делаете асинхронные вызовы (или даже просто последовательные) к серверному коду — вы тоже используете монады.</p>

<p>Когда вы просите одну функцию вызвать другую или несколько, в неком чистом окружении, и ждёте от них ответ — вы используете монады.</p>

<p>(Кстати, пока я искал материал к статье, нашёл всё-таки <a href="http://sovety.blogspot.com/2009/09/haskell-horrors.html">одно описание на русском</a> (глава 4), которое, к моему приятному удивлению, показало, что я и правда «всё правильно понял», а пример с пайпом, оказывается, вообще стандартен для описания монадических замутов).</p>

<p>Советую заглянуть в статьи по ссылкам в начале главы и посмотреть, как монады надо «правильно» адаптировать в JavaScript. Там, в общем случае, описываются одна-две монады и приводятся три основные функции: <code>bind</code>, переводящая переданную функцию в компонуемую форму (чтобы её можно было использовать в цепочках), <code>unit</code>, обеспечивающая унифицированный формат для вовращаемого значения функции и, опционально, <code>lift</code>, добавляющая к функции необходимые данные, чтобы передавать их по цепочке.</p>

<p>Но ввиду неприспособленности JS к настолько абстрактным понятиям, многие реализации требует своих версий этих функций и значительных усилий над собой, чтобы всё это верно организовать. Может где-то недалеко и пишут уже фреймворк с прямой трансляцией хаскелевских монад на JS и это наверное хорошо.</p>

<p>Но я имею привычку отмечать, что «Жаваскрипту — Жаваскриптовое».</p>

<p>Так что хватит этой напыщенной чистоты, пора и грязь познать :)</p>

<p><a name="point-5"></a></p>

<h2>Путь 5. «Грязноватые» (но от этого такие простые) монады или «Мы можем это сами»</h2>

<h4>モナダの土道</h4>

<p>Из предыдущего раздела мы узнали что такое монады и как, примерно, они должны «правильно» готовиться. Но, как я люблю говаривать, «Хаскелю — Хаскелево». Монады — общее достояние и каждый язык имеет право смотреть на них со своей колокольни. В статьях, ссылки на которые вы найдёте предыдущей главе, они адаптируются в язык не то чтобы дословно, но довольно тщательно — авторы стремятся дать почти идентичное хаскелевому решение, универсальное для всех функций. На самом же деле это больше концепция, чем необходимость дословной реализации и таскания её за собой.</p>

<p>JS на самом деле не особо предусмотрен для таких инъекций, код становится только толще и сложнее, а таскать за собой ещё парочку js-файлов, раз этого нет в явном виде в стандарте языка иногда очень даже «не комильфо». Для того чтобы подход стал простым, надо кое-от-чего отказаться.</p>

<p>Откажемся от передачи контекстов, условимся, что контекст у нас внешний и функции могут в него свободно писать. Сначала может показаться, что реализация станет зависимой от задачи, но это совсем не так: наоборот, мы оставим на своё усмотрение операции над контекстом и доверимся одной-единственной функции, которая будет превращать другую, переданную ей, функцию в отложенную и компонуемую. Вот она:</p>

<source lang="javascript">function deferrable(f) { // выберите название поприятнее
  return function() {
    return (function(f, args) {
      return function() { return f.apply(null, args); };
    })(f, arguments);
  }
}
</source>
<p>Я свернул пару строчек в одну, чтобы их правда было семь :).</p>

<p>Это изящное, на мой взгляд, сочетание тех самых <code>bind</code> и <code>unit</code>.</p>

<p>Посмотрим, как можно это использовать. Допустим, мы хотим манипулировать чтением файлов, делая это по цепочке и обрывая цепочку, если файл не был найден.</p>

<source lang="javascript">/* функция, вызовы к которой мы хотим уметь откладывать */
function read_file(name) {
  console.log('reading ' + name);
  return name !== 'foo.js'; // true, если имя файла не `foo.js`
}
</source>
<p>Заметим, однако, что для этого простейшего случая, мы уже умеем это делать:</p>

<source lang="javascript">/* мы можем эмулировать метод "прервать очередь по падению" через оператор &amp;&amp;
                    или метод "прервать по первой удаче" используя оператор ||
   но это всё.

   обратите внимание, что `read_file('c')` не вызывается. */
read_file('a') &amp;&amp; read_file('b') &amp;&amp; read_file('foo.js') &amp;&amp; read_file('c');
// &gt; reading a
// &gt; reading b
// &gt; reading foo.js
// &lt; false
</source>
<p>Если условиться, что функция возвращает более осмысленное значение (например, ссылку на файл) и <code>null</code> при ошибке (но помните о <em>MayBe</em>), то в JS мы можем сделать даже так:</p>

<source lang="javascript">var found = find_file('foo.js') || find_file('a') || find_file('b');
// &gt; found
// &lt; [file 'a']
</source>
<p>Пояснение бы не было полным, если бы мы не сэмулировали это поведение через функции. Функция, которая эмулирует поведение <code>&amp;&amp;</code>, выглядит примерно так:</p>

<source lang="javascript">/* некая функция, которая оперирует над списком других функций
   более хитрым способом

   подготавливает их, прерывает, всё что угодно... */
function smart_and() {
  var fs = arguments, // массив отложенных функций
      flen = fs.length;
  for (var i = 0; i &lt; flen; i++) {
    // если функция не сработала, остановить процесс
    if (!fs[i]()) return; 
  };
}    
</source>
<p>А функция, которая эмулирует поведение <code>||</code>, выглядит примерно так:</p>

<source lang="javascript">function smart_or() {
  var fs = arguments, // массив отложенных функций
      flen = fs.length,
      res = null;
  for (var i = 0; i &lt; flen; i++) {
    // если функция сработала, вернуть результат
    if (res = fs[i]()) return res; 
  };
}
</source>
<p>Но если мы захотим использовать одну из них, то нам придётся сделать что-то такое:</p>

<source lang="javascript">/* мы можем использовать smart_and таким вот образом, 
   но выглядит, честно говоря, хреново

   да, мы можем обпередаваться внутрь массивами имён файлов
   и обрабатывать их внутри, но тогда надо будет назвать её не 
   smart_and, а скорее smart_read_file */
smart_and(function() { return read_file('a') }, 
          function() { return read_file('b') },
          function() { return read_file('foo.js') }, 
          function() { return read_file('c') });
// &gt; reading a
// &gt; reading b
// &gt; reading foo.js
// &lt; undefined
</source>
<p>Вся проблема здесь в подготовке массива отложенных функций. Как в JS можно вызвать функцию, передав ей параметр, запомнив его, но не выполняя её тела пока к ней не было обращения, как это делают <code>||</code>/<code>&amp;&amp;</code>? Очень просто, она должна вернуть внутреннюю функцию, содержащую своё тело:</p>

<source lang="javascript">function my_func(arg) {
  return function() {
    console.log(arg);
  }
}
// &gt; var f = my_func(['a', 0]);
// &gt; f
// &lt; [function]
// &gt; f(); // или напрямую: my_func(['a', 0])();
// &lt; [ "a", 0 ]
</source>
<p>Но это не самый приятный подход, оборачивать так каждую функцию быстро надоест и выведет вас из себя… Так вот же, наверху, семистрочное решение всех ваших проблем:</p>

<source lang="javascript">function _log(a) { console.log(a); }
_log = deferrable(_log);
// &gt; _log('Hi!');
// &lt; [function]
// &gt; _log('Mooo!')();
// &lt; Moo!
</source>
<p>Вуаля:</p>

<source lang="javascript">// делаем `read_file` откладываемой
read_file = deferrable(read_file);

/* ... достаточно круто, ведь правда?

   обратите внимание, что `read_file('c')` не исполняется… */
smart_and(read_file('a'), read_file('b'), 
          read_file('foo.js'), read_file('c'));
// &gt; reading a
// &gt; reading b
// &gt; reading foo.js
// &lt; undefined
</source>
<p>Настало время, однако, представить, что наша задача сложнее и нам нужно, например, передать последний найденный файл в следующую функцию — операторы <code>||</code>/<code>&amp;&amp;</code> здесь уже совсем не подойдут. А то ведь не очень понятно, зачем мы угулбились в эти странные эмуляции операторов, если всё можно сделать их посредством без лишнего кода. <em>Вовсе не всё, на что способны монады.</em> И, нужно рассмотреть неоднозначный момент с ошибками.</p>

<source lang="javascript">function cell_1(prev) {
  console.log('c1:prev', prev, '-&gt;1');
  return 1; // если бы мы возвращали ноль, 
            // то условие ниже посчитало бы, что
            // функция не прошла
}
cell_1 = deferrable(cell_1); 
// PS. не создайте случайно глобальную переменную

function cell_2(prev) {
  console.log('c2:prev', prev, '-&gt;2'); return 2;
}
cell_2 = deferrable(cell_2); 

function cell_3(prev) {
  console.log('c3:prev', prev, '-&gt;3'); return 3;
}
cell_3 = deferrable(cell_3);

function cell_err(prev) {
  console.log('err:prev', prev, '-&gt;err'); return false; // или 0?
}
cell_err = deferrable(cell_err);

function piped() {
   var fs = arguments, // массив отложенных функций
       flen = fs.length,
       res = null;
   for (var i = 0; i &lt; flen; i++) {
     // обратите внимание, что вызов происходит внутри,
     // в отличие от предыдущих вариантов
     if (!(res = fs[i](res)())) throw new Error('NaN!');
   };
}
</source>
<p>Проверим:</p>

<source lang="javascript">piped(cell_1(...), cell_2(...) ......) // Эммм...... нет...
piped(cell_1, cell_3, cell_2, cell_3, cell_err, cell_1); // А, вот!
// c1:prev null -&gt;1
// c3:prev 1 -&gt;3
// c2:prev 3 -&gt;2
// c3:prev 2 -&gt;3
// err:prev 3 -&gt;err
// Uncaught Error: NaN!
</source>
<p>Или вот, очень актуальная задача, генератор парсеров с правилами и блекджеком. Такой, чтобы можно было сказать…:</p>

<p>(Я этим как раз сейчас занимаюсь, <a href="https://github.com/shamansir/pegjs/tree/compact-result">оптимизирую тут один генератор парсеров</a>, который для сложных синтаксисов выдаёт парсеры на несколько мегабайт JS-кода, что, в поисках красоты и справедливости, и привело меня неожиданно к монадам, поэтому у меня есть готовый пример)</p>

<source lang="javascript">// start = ("a"* / "b") "c" (d:f+ { return d.join(':'); })
// f = "YY" "d"+
// "aaacYYddYYdd" -&gt; [ ["a","a","a"], "c", "YY,d,d:YY,d,d" ]

start = function() { return sequence(
                         choise(
                           any(match("a")),
                           match("b")
                         ),
                         action(
                           label("d", some(rule_f)),
                           function() { return d.join(':'); } 
                         )
                      )(); }

rule_f = function() { return sequence(
                               match("YY"),
                               some(match("d"))();

. . .

console.log(parse("aaacYYddYYdd"));
// &gt; [ ["a","a","a"], "c", "YY,d,d:YY,d,d" ]
</source>
<p>Такие функции вполне могут возвратить и пустые строки и <code>undefined</code> (см. <code>action</code>), которые будут являться вполне полноправным значением и оно не будет значить, что что-то упало: просто не совпал элемент, но парсинг-то продолжается.</p>

<p>Ни одна из этих функций не должна выполняться по месту вызова, <code>choise</code> может пропустить последний элемент, если совпал первый, должен иметь возможность остановиться в нужный момент и откатиться назад. В этом коде я использую тот же самый <code>deferrable</code>, который я привёл выше, и это мой единственный молоток.</p>

<p>Все <a href="https://github.com/shamansir/pegjs/blob/compact-result/test/temp.js">используемые функции парсера</a> не сильно сложнее по коду, чем примеры выше, пара-тройка строк на каждую простую, пять-десять на каждую сложную.</p>

<p><code>sequence</code>, например, подобно <code>smart_or</code> выше, собирает результаты совпавших функций в массив и возвращает его, благодаря чему переменная результата парсинга (вот этот сложносоставной массив) нигде не определена и блуждает по парсеру до окончания его действия и обретает однозначную сущность только по возвращению из функции <code>parse</code>.</p>

<p>Плюс, эксепшны. Тут они подходят как нельзя кстати. Они обычно занимают кучу кода, а мне важен каждый байт, поэтому я тоже обернул их в функции:</p>

<source lang="javascript">// сообщить об ошибке
function failed(expected, found) {
  failures.push(expected); // да, failures объявлен извне,
                           // мне важны простота и размер кода 
  throw new MatchFailed(expected, found);
}

// подавить ошибку при вызове функции и известить о ней коллбэк, 
// если таковой указан
function safe(f, cb) {
  try { return f();
  } catch(e) {
    if (e instanceof MatchFailed) {
      if (cb) cb(e);
    } else { throw e; }
  }
}
</source>
<p>Именно функция <code>safe</code> подавляет ошибки, брошенные при несовпадении, например, от <code>match</code>, перехватывая их, например, для <code>choise</code>, который при неудаче просто переходит к следующему варианту.</p>

<p>Минус такого подхода в том, что эта самая блуждающая переменная результата при выбросе исключения теряется. Вернее, каждый раз перед потенциальной неудачей, её нужно сохранять (например, передавать в <code>failed</code>). То есть, если вы собираете использовать сгенерированный парсер чтобы подсвечивать текст в редакторе (например, маркдаун) на лету, то вы могли бы как раз и опираться на этот эксепшн для сборки табика <em>code completion</em>. Но предыдущий-то код тоже надо подсвечивать, а прошлый результат парсинга мог и устареть.</p>

<p>В общем, с ошибками ситуации изредка и правда могут быть не однозначными: из-за сомнительности возвращаемых типов, из-за сложных структур, которые нужно восстановить при ошибке и т.п. поэтому, в этих редких случаях, приемлемо по-хаскельному примешивать к возвращаемым значениям функций код или инстанс ошибки, например. Тут и понадобится монада <em>MayBe</em> и всяческие <code>bind</code>/<code>unit</code>.</p>

<p>Но вы ведь можете просто чётко знать, чего вы хотите достичь и что происходит в вашем коде и свободно оперировать внешними переменными. Так что, учтите — перебор действий с примешиваниями в JS — <em>это значительная жертва простоте кода</em>. Не замыкайтесь на контекст. Пользуйтесь данной вам свободой. Стремитесь к простоте. Хаскелю — Хаскелево.</p>

<p>Позже, когда закончу, я расскажу про этот парсерогенератор подробнее, а сейчас давно уже пора закругляться, поэтому эпилог:</p>

<h2>Эпилог</h2>
<p>Ну вот и всё :) Надеюсь, было понятно. <strong>Будьте проще!</strong> Чмоки-чмоки. <code>xxxxo</code>. また近いうちに </p>